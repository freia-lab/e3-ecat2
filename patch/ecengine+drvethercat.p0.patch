diff --git drvethercat.c drvethercat.c
index 12c2054..cafdaec 100644
--- drvethercat.c
+++ drvethercat.c
@@ -28,6 +28,8 @@
 
 
 #include "ec.h"
+#include <drvSup.h>
+#include <epicsExport.h>
 
 /*------------------------------------------------------------------- */
 
@@ -774,18 +776,14 @@ epicsExportRegistrar( drvethercat2_registrar );
 
 
 
-struct {
-    long number;
-    long (*report) ();
-    long (*init) ();
-} drvecat2 = {
-    1,
-    NULL, /*drvethercat_report,*/
-    NULL
+struct drvet drvecat2 = {
+    2,
+    (DRVSUPFUN) NULL, /*drvethercat_report,*/
+    (DRVSUPFUN) NULL
 };
 
 
-
+epicsExportAddress(drvet, drvecat2);
 
 
 
diff --git ecengine.c ecengine.c
index 6929166..2d31119 100644
--- ecengine.c
+++ ecengine.c
@@ -934,6 +934,7 @@ static int use_dt_1 = 0,
 void ec_worker_thread( void *data )
 {
 	int delayctr, dnr, chg = 0;
+	static uint32_t last_wc = 0;
 	struct timespec rec = { .tv_sec = 0, .tv_nsec = 50000 };
 	ethcat *ec = (ethcat *)data;
 	ec_master_t *ecm;
@@ -974,80 +975,105 @@ void ec_worker_thread( void *data )
 	ec->d->ddata.is_running = 1;
 
 	/*---------------------- */
-	while( 1 )
-	{
-
-		ecrt_master_receive( ecm );
-		ecrt_domain_process( ecd );
-
-			st_start( ECT_ECWORK_TOTAL );
-		epicsMutexMustLock( ec->rw_lock );
-			st_start( ECT_IRQ );
-		chg = irq_values_changed( ec );
-			st_end( ECT_IRQ );
-			st_start( ECT_RW );
-		memcpy( ec->d->ddata.rmem, ec->d->ddata.dmem, ec->d->ddata.dsize );
-		process_write_values( ec->d->ddata.dmem, ec->d, ec->w_mask );
-			st_end( ECT_RW );
-			st_start( ECT_STS );
-		process_sts_entries( ec->d );
-			st_end( ECT_STS );
-		epicsMutexUnlock( ec->rw_lock );
-			st_end( ECT_ECWORK_TOTAL );
-
-		if( chg )
-		{
-			epicsEventSignal( ec->irq );
-			irqs_executed[dnr]++;
-		}
+	while (1)
+	  {
+	    ec_domain_state_t ds;
+	    uint32_t wc_before, wc_after;
+
+	    /* receive + process */
+	    ecrt_master_receive(ecm);
+	    ecrt_domain_process(ecd);
+
+	    ecrt_domain_state(ecd, &ds);
+	    wc_before = ds.working_counter;
+
+	    st_start(ECT_ECWORK_TOTAL);
+	    epicsMutexMustLock(ec->rw_lock);
+
+	    st_start(ECT_IRQ);
+	    chg = irq_values_changed(ec);
+	    st_end(ECT_IRQ);
+
+	    st_start(ECT_RW);
+	    memcpy(ec->d->ddata.rmem,
+		   ec->d->ddata.dmem,
+		   ec->d->ddata.dsize);
+	    process_write_values(ec->d->ddata.dmem,
+				 ec->d,
+				 ec->w_mask);
+	    st_end(ECT_RW);
+
+	    st_start(ECT_STS);
+	    process_sts_entries(ec->d);
+	    st_end(ECT_STS);
+
+	    epicsMutexUnlock(ec->rw_lock);
+	    st_end(ECT_ECWORK_TOTAL);
+
+	    if (chg)
+	      {
+		epicsEventSignal(ec->irq);
+		irqs_executed[dnr]++;
+	      }
 
 #ifdef PRINT_DEBUG_TIMING
-		__s(1);
+	    __s(1);
 #endif
-		ecrt_domain_queue( ecd );
-		ecrt_master_send( ecm );
+
+	    /* queue + send */
+	    ecrt_domain_queue(ecd);
+	    ecrt_master_send(ecm);
+
 #ifdef PRINT_DEBUG_TIMING
-		__e(1);
+	    __e(1);
 #endif
 
-		forwarded[dnr] += (tmr_wait( 0 ) - 1);
+	    forwarded[dnr] += (tmr_wait(0) - 1);
 
-		delayctr = 0;
-		while( 1 )
-		{
+	    /* wait for new domain data */
+	    delayctr = 0;
+	    while (1)
+	      {
 #ifdef PRINT_DEBUG_TIMING
-			__s(2);
+		__s(2);
 #endif
-            ecrt_master_receive( ecm );
+		ecrt_master_receive(ecm);
+		ecrt_domain_process(ecd);
 #ifdef PRINT_DEBUG_TIMING
-    		__e(2);
+		__e(2);
 #endif
-    		if( ecrt_domain_received( ecd ) )
-    		{
-    			recd[dnr]++;
-            	break;
-    		}
 
-			if( ++delayctr > 50 )
-			{
-				dropped[dnr]++;
-				break;
-			}
-			clock_nanosleep( CLOCK_MONOTONIC, 0, &rec, NULL );
-		}
+		ecrt_domain_state(ecd, &ds);
+		wc_after = ds.working_counter;
 
-		if( delayctr )
-		{
-			delayed[dnr]++;
-			delayctr_cumulative[dnr] += (double)delayctr;
-		}
-		wt_counter[dnr]++;
+		if (wc_after != wc_before)
+		  {
+		    recd[dnr]++;
+		    break;
+		  }
+
+		if (++delayctr > 50)
+		  {
+		    dropped[dnr]++;
+		    break;
+		  }
+
+		clock_nanosleep(CLOCK_MONOTONIC, 0, &rec, NULL);
+	      }
+
+	    if (delayctr)
+	      {
+		delayed[dnr]++;
+		delayctr_cumulative[dnr] += (double)delayctr;
+	      }
+
+	    wt_counter[dnr]++;
 
 #ifdef PRINT_DEBUG_TIMING
-		__p(1);
-		__p(2);
+	    __p(1);
+	    __p(2);
 #endif
-	}
+	  }
 
 	ec->d->ddata.is_running = 0;
 
diff --git ecrt.h ecrt.h
index 1940a67..3ab462f 100644
--- ecrt.h
+++ ecrt.h
@@ -1,8 +1,6 @@
-/******************************************************************************
- *
- *  $Id: ecrt.h,v 1.1 2015/07/21 07:35:54 maier_d Exp $
+/*****************************************************************************
  *
- *  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+ *  Copyright (C) 2006-2024  Florian Pose, Ingenieurgemeinschaft IgH
  *
  *  This file is part of the IgH EtherCAT master userspace library.
  *
@@ -18,15 +16,9 @@
  *
  *  You should have received a copy of the GNU Lesser General Public License
  *  along with the IgH EtherCAT master userspace library. If not, see
- *  <http:/www.gnu.org/licenses/>.
- *
- *  ---
- *
- *  The license mentioned above concerns the source code only. Using the
- *  EtherCAT technology and brand is only permitted in compliance with the
- *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *  <http://www.gnu.org/licenses/>.
  *
- *****************************************************************************/
+ ****************************************************************************/
 
 /** \file
  *
@@ -39,6 +31,34 @@
  * request a master, to map process data, to communicate with slaves via CoE
  * and to configure and activate the bus.
  *
+ *
+ * Changes in version 1.6.0:
+ *
+ * - Added the ecrt_master_scan_progress() method, the
+ *   ec_master_scan_progress_t structure and the EC_HAVE_SCAN_PROGRESS
+ *   definition to check for its existence.
+ * - Added the EoE configuration methods ecrt_slave_config_eoe_mac_address(),
+ *   ecrt_slave_config_eoe_ip_address(), ecrt_slave_config_eoe_subnet_mask(),
+ *   ecrt_slave_config_eoe_default_gateway(),
+ *   ecrt_slave_config_eoe_dns_address(),
+ *   ecrt_slave_config_eoe_hostname() and the EC_HAVE_SET_IP
+ *   definition to check for its existence.
+ * - Added ecrt_slave_config_state_timeout() to set the application-layer
+ *   state change timeout and EC_HAVE_STATE_TIMEOUT to check for its
+ *   existence.
+ *
+ * Changes since version 1.5.2:
+ *
+ * - Added the ecrt_slave_config_flag() method and the EC_HAVE_FLAGS
+ *   definition to check for its existence.
+ * - Added SoE IDN requests, including the datatype ec_soe_request_t and the
+ *   methods ecrt_slave_config_create_soe_request(),
+ *   ecrt_soe_request_object(), ecrt_soe_request_timeout(),
+ *   ecrt_soe_request_data(), ecrt_soe_request_data_size(),
+ *   ecrt_soe_request_state(), ecrt_soe_request_write() and
+ *   ecrt_soe_request_read(). Use the EC_HAVE_SOE_REQUESTS to check, if the
+ *   functionality is available.
+ *
  * Changes in version 1.5.2:
  *
  * - Added redundancy_active flag to ec_domain_state_t.
@@ -47,7 +67,7 @@
  * - Added the EC_HAVE_REDUNDANCY define, to check, if the interface contains
  *   redundancy features.
  * - Added ecrt_sdo_request_index() to change SDO index and subindex after
- *   handler creation.
+ *   request creation.
  * - Added interface for retrieving CoE emergency messages, i. e.
  *   ecrt_slave_config_emerg_size(), ecrt_slave_config_emerg_pop(),
  *   ecrt_slave_config_emerg_clear(), ecrt_slave_config_emerg_overruns() and
@@ -88,10 +108,10 @@
  *   ecrt_slave_config_sync_manager()).
  * - Added ecrt_slave_config_complete_sdo() method to download an SDO during
  *   configuration via CompleteAccess.
- * - Added ecrt_master_deactivate() to remove the bus configuration.
+ * - Added ecrt_master_deactivate() to remove the master configuration.
  * - Added ecrt_open_master() and ecrt_master_reserve() separation for
  *   userspace.
- * - Added bus information interface (methods ecrt_master(),
+ * - Added master information interface (methods ecrt_master(),
  *   ecrt_master_get_slave(), ecrt_master_get_sync_manager(),
  *   ecrt_master_get_pdo() and ecrt_master_get_pdo_entry()) to get information
  *   about the currently connected slaves and the PDO entries provided.
@@ -115,7 +135,7 @@
  * @{
  */
 
-/*****************************************************************************/
+/****************************************************************************/
 
 #ifndef __ECRT_H__
 #define __ECRT_H__
@@ -124,15 +144,17 @@
 #include <asm/byteorder.h>
 #include <linux/types.h>
 #include <linux/time.h>
+#include <linux/in.h> // struct in_addr
 #else
-#include <stdlib.h> /* for size_t */
+#include <stdlib.h> // for size_t
 #include <stdint.h>
-#include <sys/time.h> /* for struct timeval */
+#include <sys/time.h> // for struct timeval
+#include <netinet/in.h> // struct in_addr
 #endif
 
-/******************************************************************************
+/*****************************************************************************
  * Global definitions
- *****************************************************************************/
+ ****************************************************************************/
 
 /** EtherCAT realtime interface major version number.
  */
@@ -140,7 +162,7 @@
 
 /** EtherCAT realtime interface minor version number.
  */
-#define ECRT_VER_MINOR 5
+#define ECRT_VER_MINOR 6
 
 /** EtherCAT realtime interface version word generator.
  */
@@ -150,9 +172,9 @@
  */
 #define ECRT_VERSION_MAGIC ECRT_VERSION(ECRT_VER_MAJOR, ECRT_VER_MINOR)
 
-/******************************************************************************
+/*****************************************************************************
  * Feature flags
- *****************************************************************************/
+ ****************************************************************************/
 
 /** Defined, if the redundancy features are available.
  *
@@ -187,7 +209,52 @@
  */
 #define EC_HAVE_REG_BY_POS
 
-/*****************************************************************************/
+/** Defined if the method ecrt_master_sync_reference_clock_to() is available.
+ */
+#define EC_HAVE_SYNC_TO
+
+/** Defined if the method ecrt_slave_config_flag() is available.
+ */
+#define EC_HAVE_FLAGS
+
+/** Defined if the methods ecrt_slave_config_create_soe_request(),
+ * ecrt_soe_request_object(), ecrt_soe_request_timeout(),
+ * ecrt_soe_request_data(), ecrt_soe_request_data_size(),
+ * ecrt_soe_request_state(), ecrt_soe_request_write() and
+ * ecrt_soe_request_read() and the datatype ec_soe_request_t are available.
+ */
+#define EC_HAVE_SOE_REQUESTS
+
+/** Defined, if the method ecrt_master_scan_progress() and the
+ * ec_master_scan_progress_t structure are available.
+ */
+#define EC_HAVE_SCAN_PROGRESS
+
+/** Defined, if the methods ecrt_slave_config_eoe_mac_address(),
+ * ecrt_slave_config_eoe_ip_address(), ecrt_slave_config_eoe_subnet_mask(),
+ * ecrt_slave_config_eoe_default_gateway(),
+ * ecrt_slave_config_eoe_dns_address(), ecrt_slave_config_eoe_hostname() are
+ * available.
+ */
+#define EC_HAVE_SET_IP
+
+/** Defined, if the method ecrt_slave_config_state_timeout() is available.
+ */
+#define EC_HAVE_STATE_TIMEOUT
+
+/****************************************************************************/
+
+/** Symbol visibility control macro.
+ */
+#ifndef EC_PUBLIC_API
+# if defined(ethercat_EXPORTS) && !defined(__KERNEL__)
+#  define EC_PUBLIC_API __attribute__ ((visibility ("default")))
+# else
+#  define EC_PUBLIC_API
+# endif
+#endif
+
+/****************************************************************************/
 
 /** End of list marker.
  *
@@ -225,9 +292,9 @@
  */
 #define EC_COE_EMERGENCY_MSG_SIZE 8
 
-/******************************************************************************
+/*****************************************************************************
  * Data types
- *****************************************************************************/
+ ****************************************************************************/
 
 struct ec_master;
 typedef struct ec_master ec_master_t; /**< \see ec_master */
@@ -241,13 +308,16 @@ typedef struct ec_domain ec_domain_t; /**< \see ec_domain */
 struct ec_sdo_request;
 typedef struct ec_sdo_request ec_sdo_request_t; /**< \see ec_sdo_request. */
 
+struct ec_soe_request;
+typedef struct ec_soe_request ec_soe_request_t; /**< \see ec_soe_request. */
+
 struct ec_voe_handler;
 typedef struct ec_voe_handler ec_voe_handler_t; /**< \see ec_voe_handler. */
 
 struct ec_reg_request;
-typedef struct ec_reg_request ec_reg_request_t; /**< \see ec_sdo_request. */
+typedef struct ec_reg_request ec_reg_request_t; /**< \see ec_reg_request. */
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Master state.
  *
@@ -261,7 +331,7 @@ typedef struct {
     unsigned int al_states : 4; /**< Application-layer states of all slaves.
                                   The states are coded in the lower 4 bits.
                                   If a bit is set, it means that at least one
-                                  slave in the bus is in the corresponding
+                                  slave in the network is in the corresponding
                                   state:
                                   - Bit 0: \a INIT
                                   - Bit 1: \a PREOP
@@ -271,7 +341,7 @@ typedef struct {
                                 up. */
 } ec_master_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Redundant link state.
  *
@@ -283,10 +353,10 @@ typedef struct {
     unsigned int slaves_responding; /**< Sum of responding slaves on the given
                                       link. */
     unsigned int al_states : 4; /**< Application-layer states of the slaves on
-                                  the given link.  The states are coded in the
-                                  lower 4 bits.  If a bit is set, it means
-                                  that at least one slave in the bus is in the
-                                  corresponding state:
+                                  the given link. The states are coded in the
+                                  lower 4 bits. If a bit is set, it means
+                                  that at least one slave in the network is in
+                                  the corresponding state:
                                   - Bit 0: \a INIT
                                   - Bit 1: \a PREOP
                                   - Bit 2: \a SAFEOP
@@ -295,7 +365,7 @@ typedef struct {
                                */
 } ec_master_link_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Slave configuration state.
  *
@@ -317,7 +387,7 @@ typedef struct  {
                                  bit! */
 } ec_slave_config_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Master information.
  *
@@ -326,13 +396,30 @@ typedef struct  {
  * \see ecrt_master().
  */
 typedef struct {
-   unsigned int slave_count; /**< Number of slaves in the bus. */
-   unsigned int link_up : 1; /**< \a true, if the network link is up. */
-   uint8_t scan_busy; /**< \a true, while the master is scanning the bus */
-   uint64_t app_time; /**< Application time. */
+    unsigned int slave_count; /**< Number of slaves in the network. */
+    unsigned int link_up : 1; /**< \a true, if the network link is up. */
+    uint8_t scan_busy; /**< \a true, while the master is scanning the network.
+                        */
+    uint64_t app_time; /**< Application time. */
 } ec_master_info_t;
 
-/*****************************************************************************/
+/****************************************************************************/
+
+/** Master scan progress information.
+ *
+ * This is used as an output parameter of ecrt_master_scan_progress().
+ *
+ * \see ecrt_master_scan_progress().
+ */
+typedef struct {
+    unsigned int slave_count; /**< Number of slaves detected. */
+    unsigned int scan_index; /**< Index of the slave that is currently
+                               scanned.  If it is less than the \a
+                               slave_count, the network scan is in progress.
+                              */
+} ec_master_scan_progress_t;
+
+/****************************************************************************/
 
 /** EtherCAT slave port descriptor.
  */
@@ -343,7 +430,7 @@ typedef enum {
     EC_PORT_MII /**< Port is a MII. */
 } ec_slave_port_desc_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** EtherCAT slave port information.
  */
@@ -353,7 +440,7 @@ typedef struct {
     uint8_t signal_detected; /**< Detected signal on RX port. */
 } ec_slave_port_link_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Slave information.
  *
@@ -385,7 +472,7 @@ typedef struct {
     char name[EC_MAX_STRING_LENGTH]; /**< Name of the slave. */
 } ec_slave_info_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Domain working counter interpretation.
  *
@@ -398,7 +485,7 @@ typedef enum {
     EC_WC_COMPLETE    /**< All registered process data were exchanged. */
 } ec_wc_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Domain state.
  *
@@ -410,7 +497,7 @@ typedef struct {
     unsigned int redundancy_active; /**< Redundant link is in use. */
 } ec_domain_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Direction type for PDO assignment functions.
  */
@@ -421,7 +508,7 @@ typedef enum {
     EC_DIR_COUNT /**< Number of directions. For internal use only. */
 } ec_direction_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Watchdog mode for sync manager configuration.
  *
@@ -433,7 +520,7 @@ typedef enum {
     EC_WD_DISABLE, /**< Disable the watchdog. */
 } ec_watchdog_mode_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** PDO entry configuration information.
  *
@@ -447,7 +534,7 @@ typedef struct {
     uint8_t bit_length; /**< Size of the PDO entry in bit. */
 } ec_pdo_entry_info_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** PDO configuration information.
  *
@@ -460,13 +547,13 @@ typedef struct {
     unsigned int n_entries; /**< Number of PDO entries in \a entries to map.
                               Zero means, that the default mapping shall be
                               used (this can only be done if the slave is
-                              present at bus configuration time). */
-    ec_pdo_entry_info_t *entries; /**< Array of PDO entries to map. Can either
-                                    be \a NULL, or must contain at
-                                    least \a n_entries values. */
+                              present at configuration time). */
+    ec_pdo_entry_info_t const *entries; /**< Array of PDO entries to map. Can
+                                          either be \a NULL, or must contain
+                                          at least \a n_entries values. */
 } ec_pdo_info_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Sync manager configuration information.
  *
@@ -480,12 +567,12 @@ typedef struct {
                      but can also be \a 0xff to mark the end of the list. */
     ec_direction_t dir; /**< Sync manager direction. */
     unsigned int n_pdos; /**< Number of PDOs in \a pdos. */
-    ec_pdo_info_t *pdos; /**< Array with PDOs to assign. This must contain
-                            at least \a n_pdos PDOs. */
+    ec_pdo_info_t const *pdos; /**< Array with PDOs to assign. This must
+                                 contain at least \a n_pdos PDOs. */
     ec_watchdog_mode_t watchdog_mode; /**< Watchdog mode. */
 } ec_sync_info_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** List record type for PDO entry mass-registration.
  *
@@ -503,11 +590,11 @@ typedef struct {
                        (byte-)offset in the process data. */
     unsigned int *bit_position; /**< Pointer to a variable to store a bit
                                   position (0-7) within the \a offset. Can be
-                                  NULL, in which case an error is raised if the
-                                  PDO entry does not byte-align. */
+                                  NULL, in which case an error is raised if
+                                  the PDO entry does not byte-align. */
 } ec_pdo_entry_reg_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Request state.
  *
@@ -521,7 +608,7 @@ typedef enum {
     EC_REQUEST_ERROR, /**< Request processing failed. */
 } ec_request_state_t;
 
-/*****************************************************************************/
+/****************************************************************************/
 
 /** Application-layer state.
  */
@@ -532,19 +619,21 @@ typedef enum {
     EC_AL_STATE_OP = 8, /**< Operational. */
 } ec_al_state_t;
 
-/******************************************************************************
+/*****************************************************************************
  * Global functions
- *****************************************************************************/
+ ****************************************************************************/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /** Returns the version magic of the realtime interface.
+ *
+ * \apiusage{master_any,rt_safe}
  *
  * \return Value of ECRT_VERSION_MAGIC() at EtherCAT master compile time.
  */
-unsigned int ecrt_version_magic(void);
+EC_PUBLIC_API unsigned int ecrt_version_magic(void);
 
 /** Requests an EtherCAT master for realtime operation.
  *
@@ -559,9 +648,11 @@ unsigned int ecrt_version_magic(void);
  * The first master has index 0, the n-th master has index n - 1. The number
  * of masters has to be specified when loading the master module.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return Pointer to the reserved master, otherwise \a NULL.
  */
-ec_master_t *ecrt_request_master(
+EC_PUBLIC_API ec_master_t *ecrt_request_master(
         unsigned int master_index /**< Index of the master to request. */
         );
 
@@ -576,13 +667,15 @@ ec_master_t *ecrt_request_master(
  *
  * For convenience, the function ecrt_request_master() can be used.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return Pointer to the opened master, otherwise \a NULL.
  */
-ec_master_t *ecrt_open_master(
+EC_PUBLIC_API ec_master_t *ecrt_open_master(
         unsigned int master_index /**< Index of the master to request. */
         );
 
-#endif /* #ifndef __KERNEL__ */
+#endif // #ifndef __KERNEL__
 
 /** Releases a requested EtherCAT master.
  *
@@ -593,14 +686,16 @@ ec_master_t *ecrt_open_master(
  * realtime context.
  *
  * If the master was activated, ecrt_master_deactivate() is called internally.
+ *
+ * \apiusage{master_any,blocking}
  */
-void ecrt_release_master(
+EC_PUBLIC_API void ecrt_release_master(
         ec_master_t *master /**< EtherCAT master */
         );
 
-/******************************************************************************
+/*****************************************************************************
  * Master methods
- *****************************************************************************/
+ ****************************************************************************/
 
 #ifndef __KERNEL__
 
@@ -609,31 +704,35 @@ void ecrt_release_master(
  * Before an application can use PDO/domain registration functions or SDO
  * request functions on the master, it has to reserve one for exclusive use.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return 0 in case of success, else < 0
  */
-int ecrt_master_reserve(
+EC_PUBLIC_API int ecrt_master_reserve(
         ec_master_t *master /**< EtherCAT master */
         );
 
-#endif /* #ifndef __KERNEL__ */
+#endif // #ifndef __KERNEL__
 
 #ifdef __KERNEL__
 
 /** Sets the locking callbacks.
  *
  * For concurrent master access, i. e. if other instances than the application
- * want to send and receive datagrams on the bus, the application has to
+ * want to send and receive datagrams on the network, the application has to
  * provide a callback mechanism. This method takes two function pointers as
  * its parameters. Asynchronous master access (like EoE processing) is only
  * possible if the callbacks have been set.
  *
- * The task of the send callback (\a send_cb) is to decide, if the bus is
- * currently accessible and whether or not to call the ecrt_master_send_ext()
- * method.
+ * The task of the send callback (\a send_cb) is to decide, if the network
+ * hardware is currently accessible and whether or not to call the
+ * ecrt_master_send_ext() method.
  *
  * The task of the receive callback (\a receive_cb) is to decide, if a call to
  * ecrt_master_receive() is allowed and to execute it respectively.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \attention This method has to be called before ecrt_master_activate().
  */
 void ecrt_master_callbacks(
@@ -656,9 +755,11 @@ void ecrt_master_callbacks(
  * This method allocates memory and should be called in non-realtime context
  * before ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return Pointer to the new domain on success, else NULL.
  */
-ec_domain_t *ecrt_master_create_domain(
+EC_PUBLIC_API ec_domain_t *ecrt_master_create_domain(
         ec_master_t *master /**< EtherCAT master. */
         );
 
@@ -678,21 +779,23 @@ ec_domain_t *ecrt_master_create_domain(
  *   aliased slave, so a position of zero means the aliased slave itself and a
  *   positive value matches the n-th slave behind the aliased one.
  *
- * If the slave with the given address is found during the bus configuration,
+ * If the slave with the given address is found during the configuration,
  * its vendor ID and product code are matched against the given value. On
  * mismatch, the slave is not configured and an error message is raised.
  *
- * If different slave configurations are pointing to the same slave during bus
+ * If different slave configurations are pointing to the same slave during
  * configuration, a warning is raised and only the first configuration is
  * applied.
  *
  * This method allocates memory and should be called in non-realtime context
  * before ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval >0 Pointer to the slave configuration structure.
  * \retval NULL in the error case.
  */
-ec_slave_config_t *ecrt_master_slave_config(
+EC_PUBLIC_API ec_slave_config_t *ecrt_master_slave_config(
         ec_master_t *master, /**< EtherCAT master */
         uint16_t alias, /**< Slave alias. */
         uint16_t position, /**< Slave position. */
@@ -706,9 +809,11 @@ ec_slave_config_t *ecrt_master_slave_config(
  * configuration pointer is NULL, then the first slave with DC functionality
  * will provide the reference clock.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return 0 on success, otherwise negative error code.
  */
-int ecrt_master_select_reference_clock(
+EC_PUBLIC_API int ecrt_master_select_reference_clock(
         ec_master_t *master, /**< EtherCAT master. */
         ec_slave_config_t *sc /**< Slave config of the slave to use as the
                                * reference slave (or NULL). */
@@ -716,30 +821,49 @@ int ecrt_master_select_reference_clock(
 
 /** Obtains master information.
  *
- * No memory is allocated on the heap in
- * this function.
+ * No memory is allocated on the heap in this function.
+ *
+ * \apiusage{master_any,rt_safe}
  *
  * \attention The pointer to this structure must point to a valid variable.
  *
  * \return 0 in case of success, else < 0
  */
-int ecrt_master(
+EC_PUBLIC_API int ecrt_master(
         ec_master_t *master, /**< EtherCAT master */
         ec_master_info_t *master_info /**< Structure that will output the
                                         information */
         );
 
+/** Obtains network scan progress information.
+ *
+ * No memory is allocated on the heap in this function.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \attention The pointer to this structure must point to a valid variable.
+ *
+ * \return 0 in case of success, else < 0
+ */
+EC_PUBLIC_API int ecrt_master_scan_progress(
+        ec_master_t *master, /**< EtherCAT master */
+        ec_master_scan_progress_t *progress /**< Structure that will output
+                                              the progress information. */
+        );
+
 /** Obtains slave information.
  *
  * Tries to find the slave with the given ring position. The obtained
  * information is stored in a structure. No memory is allocated on the heap in
  * this function.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \attention The pointer to this structure must point to a valid variable.
  *
  * \return 0 in case of success, else < 0
  */
-int ecrt_master_get_slave(
+EC_PUBLIC_API int ecrt_master_get_slave(
         ec_master_t *master, /**< EtherCAT master */
         uint16_t slave_position, /**< Slave position. */
         ec_slave_info_t *slave_info /**< Structure that will output the
@@ -754,9 +878,11 @@ int ecrt_master_get_slave(
  * manager. The \a pdos field of the return value is left empty. Use
  * ecrt_master_get_pdo() to get the PDO information.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \return zero on success, else non-zero
  */
-int ecrt_master_get_sync_manager(
+EC_PUBLIC_API int ecrt_master_get_sync_manager(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint8_t sync_index, /**< Sync manager index. Must be less
@@ -771,9 +897,11 @@ int ecrt_master_get_sync_manager(
  * value is left empty. Use ecrt_master_get_pdo_entry() to get the PDO
  * entry information.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval zero on success, else non-zero
  */
-int ecrt_master_get_pdo(
+EC_PUBLIC_API int ecrt_master_get_pdo(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint8_t sync_index, /**< Sync manager index. Must be less
@@ -787,9 +915,11 @@ int ecrt_master_get_pdo(
  * Fills a given ec_pdo_entry_info_t structure with the attributes of a
  * currently mapped PDO entry of the given PDO.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval zero on success, else non-zero
  */
-int ecrt_master_get_pdo_entry(
+EC_PUBLIC_API int ecrt_master_get_pdo_entry(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint8_t sync_index, /**< Sync manager index. Must be less
@@ -807,15 +937,17 @@ int ecrt_master_get_pdo_entry(
  * until the request has been processed and may not be called in realtime
  * context.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_master_sdo_download(
+EC_PUBLIC_API int ecrt_master_sdo_download(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint16_t index, /**< Index of the SDO. */
         uint8_t subindex, /**< Subindex of the SDO. */
-        uint8_t *data, /**< Data buffer to download. */
+        const uint8_t *data, /**< Data buffer to download. */
         size_t data_size, /**< Size of the data buffer. */
         uint32_t *abort_code /**< Abort code of the SDO download. */
         );
@@ -827,14 +959,16 @@ int ecrt_master_sdo_download(
  * until the request has been processed and may not be called in realtime
  * context.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_master_sdo_download_complete(
+EC_PUBLIC_API int ecrt_master_sdo_download_complete(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint16_t index, /**< Index of the SDO. */
-        uint8_t *data, /**< Data buffer to download. */
+        const uint8_t *data, /**< Data buffer to download. */
         size_t data_size, /**< Size of the data buffer. */
         uint32_t *abort_code /**< Abort code of the SDO download. */
         );
@@ -845,10 +979,12 @@ int ecrt_master_sdo_download_complete(
  * until the request has been processed and may not be called in realtime
  * context.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_master_sdo_upload(
+EC_PUBLIC_API int ecrt_master_sdo_upload(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint16_t index, /**< Index of the SDO. */
@@ -864,15 +1000,17 @@ int ecrt_master_sdo_upload(
  * Starts writing an IDN and blocks until the request was processed, or an
  * error occurred.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_master_write_idn(
+EC_PUBLIC_API int ecrt_master_write_idn(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint8_t drive_no, /**< Drive number. */
         uint16_t idn, /**< SoE IDN (see ecrt_slave_config_idn()). */
-        uint8_t *data, /**< Pointer to data to write. */
+        const uint8_t *data, /**< Pointer to data to write. */
         size_t data_size, /**< Size of data to write. */
         uint16_t *error_code /**< Pointer to variable, where an SoE error code
                                can be stored. */
@@ -883,10 +1021,12 @@ int ecrt_master_write_idn(
  * Starts reading an IDN and blocks until the request was processed, or an
  * error occurred.
  *
+ * \apiusage{master_any,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_master_read_idn(
+EC_PUBLIC_API int ecrt_master_read_idn(
         ec_master_t *master, /**< EtherCAT master. */
         uint16_t slave_position, /**< Slave position. */
         uint8_t drive_no, /**< Drive number. */
@@ -904,33 +1044,40 @@ int ecrt_master_read_idn(
  * This function tells the master that the configuration phase is finished and
  * the realtime operation will begin. The function allocates internal memory
  * for the domains and calculates the logical FMMU addresses for domain
- * members. It tells the master state machine that the bus configuration is
- * now to be applied.
+ * members. It tells the master state machine that the configuration is
+ * now to be applied to the network.
+ *
+ * \apiusage{master_idle,blocking}
  *
  * \attention After this function has been called, the realtime application is
  * in charge of cyclically calling ecrt_master_send() and
- * ecrt_master_receive() to ensure bus communication. Before calling this
+ * ecrt_master_receive() to ensure network communication. Before calling this
  * function, the master thread is responsible for that, so these functions may
  * not be called! The method itself allocates memory and should not be called
  * in realtime context.
  *
  * \return 0 in case of success, else < 0
  */
-int ecrt_master_activate(
+EC_PUBLIC_API int ecrt_master_activate(
         ec_master_t *master /**< EtherCAT master. */
         );
 
 /** Deactivates the master.
  *
- * Removes the bus configuration. All objects created by
+ * Removes the master configuration. All objects created by
  * ecrt_master_create_domain(), ecrt_master_slave_config(), ecrt_domain_data()
  * ecrt_slave_config_create_sdo_request() and
  * ecrt_slave_config_create_voe_handler() are freed, so pointers to them
  * become invalid.
  *
+ * \apiusage{master_op,blocking}
+ *
  * This method should not be called in realtime context.
+ * \return 0 on success, otherwise negative error code.
+ * \retval 0 Success.
+ * \retval -EINVAL Master has not been activated before.
  */
-void ecrt_master_deactivate(
+EC_PUBLIC_API int ecrt_master_deactivate(
         ec_master_t *master /**< EtherCAT master. */
         );
 
@@ -941,10 +1088,12 @@ void ecrt_master_deactivate(
  * --enable-hrtimers, this is used to calculate the scheduling of the master
  * thread.
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval 0 on success.
  * \retval <0 Error code.
  */
-int ecrt_master_set_send_interval(
+EC_PUBLIC_API int ecrt_master_set_send_interval(
         ec_master_t *master, /**< EtherCAT master. */
         size_t send_interval /**< Send interval in us */
         );
@@ -956,8 +1105,12 @@ int ecrt_master_set_send_interval(
  *
  * Has to be called cyclically by the application after ecrt_master_activate()
  * has returned.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
  */
-void ecrt_master_send(
+EC_PUBLIC_API int ecrt_master_send(
         ec_master_t *master /**< EtherCAT master. */
         );
 
@@ -970,28 +1123,43 @@ void ecrt_master_send(
  *
  * Has to be called cyclically by the realtime application after
  * ecrt_master_activate() has returned.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
  */
-void ecrt_master_receive(
+EC_PUBLIC_API int ecrt_master_receive(
         ec_master_t *master /**< EtherCAT master. */
         );
 
+#ifdef __KERNEL__
 /** Sends non-application datagrams.
  *
  * This method has to be called in the send callback function passed via
  * ecrt_master_callbacks() to allow the sending of non-application datagrams.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
+ * \retval -EAGAIN Lock could not be acquired, try again later.
  */
-void ecrt_master_send_ext(
+int ecrt_master_send_ext(
         ec_master_t *master /**< EtherCAT master. */
         );
+#endif
 
 /** Reads the current master state.
  *
  * Stores the master state information in the given \a state structure.
  *
  * This method returns a global state. For the link-specific states in a
- * redundant bus topology, use the ecrt_master_link_state() method.
+ * redundant network topology, use the ecrt_master_link_state() method.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
  */
-void ecrt_master_state(
+EC_PUBLIC_API int ecrt_master_state(
         const ec_master_t *master, /**< EtherCAT master. */
         ec_master_state_t *state /**< Structure to store the information. */
         );
@@ -1000,9 +1168,11 @@ void ecrt_master_state(
  *
  * Stores the link state information in the given \a state structure.
  *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return Zero on success, otherwise negative error code.
  */
-int ecrt_master_link_state(
+EC_PUBLIC_API int ecrt_master_link_state(
         const ec_master_t *master, /**< EtherCAT master. */
         unsigned int dev_idx, /**< Index of the device (0 = main device, 1 =
                                 first backup device, ...). */
@@ -1016,11 +1186,11 @@ int ecrt_master_link_state(
  * distributed clocks. The time is not incremented by the master itself, so
  * this method has to be called cyclically.
  *
- * \attention The first call of this method is used to calculate the phase
- * delay for the slaves' SYNC0/1 interrupts. Either the method has to be
- * called during the realtime cycle *only*, or the first time submitted must
- * be in-phase with the realtime cycle. Otherwise synchronisation problems can
- * occur.
+ * \attention The time passed to this method is used to calculate the phase of
+ * the slaves' SYNC0/1 interrupts. It should be called constantly at the same
+ * point of the realtime cycle. So it is recommended to call it at the start
+ * of the calculations to avoid deviancies due to changing execution times.
+ * Avoid calling this method before the realtime cycle is established.
  *
  * The time is used when setting the slaves' <tt>System Time Offset</tt> and
  * <tt>Cyclic Operation Start Time</tt> registers and when synchronizing the
@@ -1028,9 +1198,14 @@ int ecrt_master_link_state(
  * ecrt_master_sync_reference_clock().
  *
  * The time is defined as nanoseconds from 2000-01-01 00:00. Converting an
- * epoch time can be done with the EC_TIMEVAL2NANO() macro.
+ * epoch time can be done with the EC_TIMEVAL2NANO() macro, but is not
+ * necessary, since the absolute value is not of any interest.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
  */
-void ecrt_master_application_time(
+EC_PUBLIC_API int ecrt_master_application_time(
         ec_master_t *master, /**< EtherCAT master. */
         uint64_t app_time /**< Application time. */
         );
@@ -1039,16 +1214,50 @@ void ecrt_master_application_time(
  *
  * The reference clock will by synchronized to the application time provided
  * by the last call off ecrt_master_application_time().
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
+ * \retval 0 Success.
+ * \retval -ENXIO No reference clock found.
  */
-void ecrt_master_sync_reference_clock(
+EC_PUBLIC_API int ecrt_master_sync_reference_clock(
         ec_master_t *master /**< EtherCAT master. */
         );
 
+/** Queues the DC reference clock drift compensation datagram for sending.
+ *
+ * The reference clock will by synchronized to the time passed in the
+ * sync_time parameter.
+ *
+ * Has to be called by the application after ecrt_master_activate()
+ * has returned.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise negative error code.
+ * \retval 0 Success.
+ * \retval -ENXIO No reference clock found.
+ */
+EC_PUBLIC_API int ecrt_master_sync_reference_clock_to(
+        ec_master_t *master, /**< EtherCAT master. */
+        uint64_t sync_time /**< Sync reference clock to this time. */
+        );
+
 /** Queues the DC clock drift compensation datagram for sending.
  *
  * All slave clocks synchronized to the reference clock.
+ *
+ * Has to be called by the application after ecrt_master_activate()
+ * has returned.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval 0 Success.
+ * \retval -ENXIO No reference clock found.
  */
-void ecrt_master_sync_slave_clocks(
+EC_PUBLIC_API int ecrt_master_sync_slave_clocks(
         ec_master_t *master /**< EtherCAT master. */
         );
 
@@ -1064,12 +1273,18 @@ void ecrt_master_sync_slave_clocks(
  * \attention The returned time is the system time of the reference clock
  * minus the transmission delay of the reference clock.
  *
+ * Calling this method makes only sense in realtime context (after master
+ * activation), when the ecrt_master_sync_slave_clocks() method is called
+ * cyclically.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
  * \retval 0 success, system time was written into \a time.
  * \retval -ENXIO No reference clock found.
  * \retval -EIO Slave synchronization datagram was not received.
  */
-int ecrt_master_reference_clock_time(
-        ec_master_t *master, /**< EtherCAT master. */
+EC_PUBLIC_API int ecrt_master_reference_clock_time(
+        const ec_master_t *master, /**< EtherCAT master. */
         uint32_t *time /**< Pointer to store the queried system time. */
         );
 
@@ -1078,8 +1293,12 @@ int ecrt_master_reference_clock_time(
  * The datagram broadcast-reads all "System time difference" registers (\a
  * 0x092c) to get an upper estimation of the DC synchrony. The result can be
  * checked with the ecrt_master_sync_monitor_process() method.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Zero on success, otherwise a negative error code.
  */
-void ecrt_master_sync_monitor_queue(
+EC_PUBLIC_API int ecrt_master_sync_monitor_queue(
         ec_master_t *master /**< EtherCAT master. */
         );
 
@@ -1089,10 +1308,13 @@ void ecrt_master_sync_monitor_queue(
  * ecrt_master_sync_monitor_queue(), the result can be queried with this
  * method.
  *
- * \return Upper estimation of the maximum time difference in ns.
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Upper estimation of the maximum time difference in ns, -1 on error.
+ * \retval (uint32_t)-1 Error.
  */
-uint32_t ecrt_master_sync_monitor_process(
-        ec_master_t *master /**< EtherCAT master. */
+EC_PUBLIC_API uint32_t ecrt_master_sync_monitor_process(
+        const ec_master_t *master /**< EtherCAT master. */
         );
 
 /** Retry configuring slaves.
@@ -1101,14 +1323,21 @@ uint32_t ecrt_master_sync_monitor_process(
  * OP state. In general, this is not necessary, because it is automatically
  * done by the master. But with special slaves, that can be reconfigured by
  * the vendor during runtime, it can be useful.
+ *
+ * Calling this method only makes sense in realtime context (after
+ * activation), because slaves will not be configured before.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_master_reset(
+EC_PUBLIC_API int ecrt_master_reset(
         ec_master_t *master /**< EtherCAT master. */
         );
 
-/******************************************************************************
+/*****************************************************************************
  * Slave configuration methods
- *****************************************************************************/
+ ****************************************************************************/
 
 /** Configure a sync manager.
  *
@@ -1118,9 +1347,11 @@ void ecrt_master_reset(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return zero on success, else non-zero
  */
-int ecrt_slave_config_sync_manager(
+EC_PUBLIC_API int ecrt_slave_config_sync_manager(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t sync_index, /**< Sync manager index. Must be less
                               than #EC_MAX_SYNC_MANAGERS. */
@@ -1132,17 +1363,22 @@ int ecrt_slave_config_sync_manager(
  *
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_slave_config_watchdog(
+EC_PUBLIC_API int ecrt_slave_config_watchdog(
         ec_slave_config_t *sc, /**< Slave configuration. */
-        uint16_t watchdog_divider, /**< Number of 40 ns intervals. Used as a
-                                     base unit for all slave watchdogs. If set
-                                     to zero, the value is not written, so the
-                                     default is used. */
-        uint16_t watchdog_intervals /**< Number of base intervals for process
-                                      data watchdog. If set to zero, the value
-                                      is not written, so the default is used.
-                                     */
+        uint16_t watchdog_divider, /**< Number of 40 ns intervals (register
+                                     0x0400). Used as a base unit for all
+                                     slave watchdogs^. If set to zero, the
+                                     value is not written, so the default is
+                                     used. */
+        uint16_t watchdog_intervals /**< Number of base intervals for sync
+                                      manager watchdog (register 0x0420). If
+                                      set to zero, the value is not written,
+                                      so the default is used. */
         );
 
 /** Add a PDO to a sync manager's PDO assignment.
@@ -1150,10 +1386,12 @@ void ecrt_slave_config_watchdog(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \see ecrt_slave_config_pdos()
  * \return zero on success, else non-zero
  */
-int ecrt_slave_config_pdo_assign_add(
+EC_PUBLIC_API int ecrt_slave_config_pdo_assign_add(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t sync_index, /**< Sync manager index. Must be less
                               than #EC_MAX_SYNC_MANAGERS. */
@@ -1169,9 +1407,12 @@ int ecrt_slave_config_pdo_assign_add(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \see ecrt_slave_config_pdos()
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_slave_config_pdo_assign_clear(
+EC_PUBLIC_API int ecrt_slave_config_pdo_assign_clear(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t sync_index /**< Sync manager index. Must be less
                               than #EC_MAX_SYNC_MANAGERS. */
@@ -1182,10 +1423,12 @@ void ecrt_slave_config_pdo_assign_clear(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \see ecrt_slave_config_pdos()
  * \return zero on success, else non-zero
  */
-int ecrt_slave_config_pdo_mapping_add(
+EC_PUBLIC_API int ecrt_slave_config_pdo_mapping_add(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t pdo_index, /**< Index of the PDO. */
         uint16_t entry_index, /**< Index of the PDO entry to add to the PDO's
@@ -1203,9 +1446,12 @@ int ecrt_slave_config_pdo_mapping_add(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \see ecrt_slave_config_pdos()
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_slave_config_pdo_mapping_clear(
+EC_PUBLIC_API int ecrt_slave_config_pdo_mapping_clear(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t pdo_index /**< Index of the PDO. */
         );
@@ -1223,15 +1469,15 @@ void ecrt_slave_config_pdo_mapping_clear(
  * reserve the complete process data, even if the slave is not present at
  * configuration time:
  *
- *
+ * \code
  * ec_pdo_entry_info_t el3162_channel1[] = {
- *     {0x3101, 1,  8},
- *     {0x3101, 2, 16}
+ *     {0x3101, 1,  8}, // status
+ *     {0x3101, 2, 16}  // value
  * };
  *
  * ec_pdo_entry_info_t el3162_channel2[] = {
- *     {0x3102, 1,  8},
- *     {0x3102, 2, 16}
+ *     {0x3102, 1,  8}, // status
+ *     {0x3102, 2, 16}  // value
  * };
  *
  * ec_pdo_info_t el3162_pdos[] = {
@@ -1246,7 +1492,7 @@ void ecrt_slave_config_pdo_mapping_clear(
  * };
  *
  * if (ecrt_slave_config_pdos(sc_ana_in, EC_END, el3162_syncs)) {
- *
+ *     // handle error
  * }
  * \endcode
  *
@@ -1257,8 +1503,8 @@ void ecrt_slave_config_pdo_mapping_clear(
  *
  * \code
  * ec_pdo_info_t pdos[] = {
- *     {0x1600},  Channel 1
- *     {0x1601}   Channel 2
+ *     {0x1600}, // Channel 1
+ *     {0x1601}  // Channel 2
  * };
  *
  * ec_sync_info_t syncs[] = {
@@ -1266,7 +1512,7 @@ void ecrt_slave_config_pdo_mapping_clear(
  * };
  *
  * if (ecrt_slave_config_pdos(slave_config_ana_in, 1, syncs)) {
- *     handle error
+ *     // handle error
  * }
  * \endcode
  *
@@ -1279,9 +1525,11 @@ void ecrt_slave_config_pdo_mapping_clear(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return zero on success, else non-zero
  */
-int ecrt_slave_config_pdos(
+EC_PUBLIC_API int ecrt_slave_config_pdos(
         ec_slave_config_t *sc, /**< Slave configuration. */
         unsigned int n_syncs, /**< Number of sync manager configurations in
                                 \a syncs. */
@@ -1304,10 +1552,12 @@ int ecrt_slave_config_pdos(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval >=0 Success: Offset of the PDO entry's process data.
  * \retval  <0 Error code.
  */
-int ecrt_slave_config_reg_pdo_entry(
+EC_PUBLIC_API int ecrt_slave_config_reg_pdo_entry(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t entry_index, /**< Index of the PDO entry to register. */
         uint8_t entry_subindex, /**< Subindex of the PDO entry to register. */
@@ -1326,10 +1576,12 @@ int ecrt_slave_config_reg_pdo_entry(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval >=0 Success: Offset of the PDO entry's process data.
  * \retval  <0 Error code.
  */
-int ecrt_slave_config_reg_pdo_entry_pos(
+EC_PUBLIC_API int ecrt_slave_config_reg_pdo_entry_pos(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t sync_index, /**< Sync manager index. */
         unsigned int pdo_pos, /**< Position of the PDO inside the SM. */
@@ -1351,9 +1603,12 @@ int ecrt_slave_config_reg_pdo_entry_pos(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \attention The \a sync1_shift time is ignored.
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_slave_config_dc(
+EC_PUBLIC_API int ecrt_slave_config_dc(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t assign_activate, /**< AssignActivate word. */
         uint32_t sync0_cycle, /**< SYNC0 cycle time [ns]. */
@@ -1384,10 +1639,12 @@ void ecrt_slave_config_dc(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_sdo(
+EC_PUBLIC_API int ecrt_slave_config_sdo(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t index, /**< Index of the SDO to configure. */
         uint8_t subindex, /**< Subindex of the SDO to configure. */
@@ -1402,10 +1659,12 @@ int ecrt_slave_config_sdo(
  *
  * \see ecrt_slave_config_sdo().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_sdo8(
+EC_PUBLIC_API int ecrt_slave_config_sdo8(
         ec_slave_config_t *sc, /**< Slave configuration */
         uint16_t sdo_index, /**< Index of the SDO to configure. */
         uint8_t sdo_subindex, /**< Subindex of the SDO to configure. */
@@ -1419,10 +1678,12 @@ int ecrt_slave_config_sdo8(
  *
  * \see ecrt_slave_config_sdo().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_sdo16(
+EC_PUBLIC_API int ecrt_slave_config_sdo16(
         ec_slave_config_t *sc, /**< Slave configuration */
         uint16_t sdo_index, /**< Index of the SDO to configure. */
         uint8_t sdo_subindex, /**< Subindex of the SDO to configure. */
@@ -1436,10 +1697,12 @@ int ecrt_slave_config_sdo16(
  *
  * \see ecrt_slave_config_sdo().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_sdo32(
+EC_PUBLIC_API int ecrt_slave_config_sdo32(
         ec_slave_config_t *sc, /**< Slave configuration */
         uint16_t sdo_index, /**< Index of the SDO to configure. */
         uint8_t sdo_subindex, /**< Subindex of the SDO to configure. */
@@ -1456,10 +1719,12 @@ int ecrt_slave_config_sdo32(
  *
  * \see ecrt_slave_config_sdo().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_complete_sdo(
+EC_PUBLIC_API int ecrt_slave_config_complete_sdo(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t index, /**< Index of the SDO to configure. */
         const uint8_t *data, /**< Pointer to the data. */
@@ -1474,9 +1739,11 @@ int ecrt_slave_config_complete_sdo(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return 0 on success, or negative error code.
  */
-int ecrt_slave_config_emerg_size(
+EC_PUBLIC_API int ecrt_slave_config_emerg_size(
         ec_slave_config_t *sc, /**< Slave configuration. */
         size_t elements /**< Number of records of the CoE emergency ring. */
         );
@@ -1489,20 +1756,31 @@ int ecrt_slave_config_emerg_size(
  * Byte   2: Error register
  * Byte 3-7: Data
  *
+ * Calling this method makes only sense in realtime context (after master
+ * activation).
+ *
  * \return 0 on success (record popped), or negative error code (i. e.
  * -ENOENT, if ring is empty).
+ *
+ * \apiusage{master_op,any_context}
  */
-int ecrt_slave_config_emerg_pop(
+EC_PUBLIC_API int ecrt_slave_config_emerg_pop(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t *target /**< Pointer to target memory (at least
                           EC_COE_EMERGENCY_MSG_SIZE bytes). */
         );
 
 /** Clears CoE emergency ring buffer and the overrun counter.
+ *
+ * Calling this method makes only sense in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,any_context}
  *
  * \return 0 on success, or negative error code.
+ *
  */
-int ecrt_slave_config_emerg_clear(
+EC_PUBLIC_API int ecrt_slave_config_emerg_clear(
         ec_slave_config_t *sc /**< Slave configuration. */
         );
 
@@ -1512,10 +1790,16 @@ int ecrt_slave_config_emerg_clear(
  * not be stored in the ring buffer and had to be dropped. Call
  * ecrt_slave_config_emerg_clear() to reset the counter.
  *
+ * Calling this method makes only sense in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,any_context}
+ *
  * \return Number of overruns since last clear, or negative error code.
+ *
  */
-int ecrt_slave_config_emerg_overruns(
-        ec_slave_config_t *sc /**< Slave configuration. */
+EC_PUBLIC_API int ecrt_slave_config_emerg_overruns(
+        const ec_slave_config_t *sc /**< Slave configuration. */
         );
 
 /** Create an SDO request to exchange SDOs during realtime operation.
@@ -1526,15 +1810,36 @@ int ecrt_slave_config_emerg_overruns(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return New SDO request, or NULL on error.
  */
-ec_sdo_request_t *ecrt_slave_config_create_sdo_request(
+EC_PUBLIC_API ec_sdo_request_t *ecrt_slave_config_create_sdo_request(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint16_t index, /**< SDO index. */
         uint8_t subindex, /**< SDO subindex. */
         size_t size /**< Data size to reserve. */
         );
 
+/** Create an SoE request to exchange SoE IDNs during realtime operation.
+ *
+ * The created SoE request object is freed automatically when the master is
+ * released.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \return New SoE request, or NULL on error.
+ */
+EC_PUBLIC_API ec_soe_request_t *ecrt_slave_config_create_soe_request(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        uint8_t drive_no, /**< Drive number. */
+        uint16_t idn, /**< Sercos ID-Number. */
+        size_t size /**< Data size to reserve. */
+        );
+
 /** Create an VoE handler to exchange vendor-specific data during realtime
  * operation.
  *
@@ -1548,9 +1853,11 @@ ec_sdo_request_t *ecrt_slave_config_create_sdo_request(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return New VoE handler, or NULL on error.
  */
-ec_voe_handler_t *ecrt_slave_config_create_voe_handler(
+EC_PUBLIC_API ec_voe_handler_t *ecrt_slave_config_create_voe_handler(
         ec_slave_config_t *sc, /**< Slave configuration. */
         size_t size /**< Data size to reserve. */
         );
@@ -1567,9 +1874,11 @@ ec_voe_handler_t *ecrt_slave_config_create_voe_handler(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \return New register request, or NULL on error.
  */
-ec_reg_request_t *ecrt_slave_config_create_reg_request(
+EC_PUBLIC_API ec_reg_request_t *ecrt_slave_config_create_reg_request(
         ec_slave_config_t *sc, /**< Slave configuration. */
         size_t size /**< Data size to reserve. */
         );
@@ -1582,8 +1891,16 @@ ec_reg_request_t *ecrt_slave_config_create_reg_request(
  *
  * \attention If the state of process data exchange shall be monitored in
  * realtime, ecrt_domain_state() should be used.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
  */
-void ecrt_slave_config_state(
+EC_PUBLIC_API int ecrt_slave_config_state(
         const ec_slave_config_t *sc, /**< Slave configuration */
         ec_slave_config_state_t *state /**< State object to write to. */
         );
@@ -1607,10 +1924,12 @@ void ecrt_slave_config_state(
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * \apiusage{master_idle,blocking}
+ *
  * \retval  0 Success.
  * \retval <0 Error code.
  */
-int ecrt_slave_config_idn(
+EC_PUBLIC_API int ecrt_slave_config_idn(
         ec_slave_config_t *sc, /**< Slave configuration. */
         uint8_t drive_no, /**< Drive number. */
         uint16_t idn, /**< SoE IDN. */
@@ -1620,82 +1939,299 @@ int ecrt_slave_config_idn(
         size_t size /**< Size of the \a data. */
         );
 
-/******************************************************************************
- * Domain methods
- *****************************************************************************/
-
-/** Registers a bunch of PDO entries for a domain.
+/** Adds a feature flag to a slave configuration.
+ *
+ * Feature flags are a generic way to configure slave-specific behavior.
+ *
+ * Multiple calls with the same slave configuration and key will overwrite the
+ * configuration.
+ *
+ * The following flags may be available:
+ * - AssignToPdi: Zero (default) keeps the slave information interface (SII)
+ *   assigned to EtherCAT (except during transition to PREOP). Non-zero
+ *   assigns the SII to the slave controller side before going to PREOP and
+ *   leaves it there until a write command happens.
+ * - WaitBeforeSAFEOPms: Number of milliseconds to wait before commanding the
+ *   transition from PREOP to SAFEOP. This can be used as a workaround for
+ *   slaves that need a little time to initialize.
  *
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
- * \see ecrt_slave_config_reg_pdo_entry()
+ * \apiusage{master_idle,blocking}
  *
- * \attention The registration array has to be terminated with an empty
- *            structure, or one with the \a index field set to zero!
- * \return 0 on success, else non-zero.
+ * \retval  0 Success.
+ * \retval <0 Error code.
  */
-int ecrt_domain_reg_pdo_entry_list(
-        ec_domain_t *domain, /**< Domain. */
-        const ec_pdo_entry_reg_t *pdo_entry_regs /**< Array of PDO
-                                                   registrations. */
+EC_PUBLIC_API int ecrt_slave_config_flag(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        const char *key, /**< Key as null-terminated ASCII string. */
+        int32_t value /**< Value to store. */
         );
 
-/** Returns the current size of the domain's process data.
+/** Sets the link/MAC address for Ethernet-over-EtherCAT (EoE) operation.
  *
- * \return Size of the process data image, or a negative error code.
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * The MAC address is stored in the slave configuration object and will be
+ * written to the slave during the configuration process.
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
  */
-size_t ecrt_domain_size(
-        const ec_domain_t *domain /**< Domain. */
+EC_PUBLIC_API int ecrt_slave_config_eoe_mac_address(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        const unsigned char *mac_address /**< MAC address. */
         );
 
-#ifdef __KERNEL__
-
-/** Provide external memory to store the domain's process data.
- *
- * Call this after all PDO entries have been registered and before activating
- * the master.
- *
- * The size of the allocated memory must be at least ecrt_domain_size(), after
- * all PDO entries have been registered.
+/** Sets the IP address for Ethernet-over-EtherCAT (EoE) operation.
  *
  * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
+ * The IP address is stored in the slave configuration object and will be
+ * written to the slave during the configuration process.
+ *
+ * The IP address is passed by-value as a `struct in_addr`. This structure
+ * contains the 32-bit IPv4 address in network byte order (big endian).
+ *
+ * A string-represented IPv4 address can be converted to a `struct in_addr`
+ * for example via the POSIX function `inet_pton()` (see man 3 inet_pton):
+ *
+ * \code{.c}
+ *     #include <arpa/inet.h>
+ *     struct in_addr addr;
+ *     if (inet_aton("192.168.0.1", &addr) == 0) {
+ *         fprintf(stderr, "Failed to convert IP address.\n");
+ *         return -1;
+ *     }
+ *     if (ecrt_slave_config_eoe_ip_address(sc, addr)) {
+ *         fprintf(stderr, "Failed to set IP address.\n");
+ *         return -1;
+ *     }
+ * \endcode
+ *
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
  */
-void ecrt_domain_external_memory(
-        ec_domain_t *domain, /**< Domain. */
-        uint8_t *memory /**< Address of the memory to store the process
-                          data in. */
+EC_PUBLIC_API int ecrt_slave_config_eoe_ip_address(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        struct in_addr ip_address /**< IPv4 address. */
         );
 
-#endif /* __KERNEL__ */
-
-/** Returns the domain's process data.
+/** Sets the subnet mask for Ethernet-over-EtherCAT (EoE) operation.
  *
- * - In kernel context: If external memory was provided with
- * ecrt_domain_external_memory(), the returned pointer will contain the
- * address of that memory. Otherwise it will point to the internally allocated
- * memory. In the latter case, this method may not be called before
+ * This method has to be called in non-realtime context before
  * ecrt_master_activate().
  *
- * - In userspace context: This method has to be called after
- * ecrt_master_activate() to get the mapped domain process data memory.
+ * The subnet mask is stored in the slave configuration object and will be
+ * written to the slave during the configuration process.
  *
- * \return Pointer to the process data memory.
+ * The subnet mask is passed by-value as a `struct in_addr`. This structure
+ * contains the 32-bit mask in network byte order (big endian).
+ *
+ * See ecrt_slave_config_eoe_ip_address() on how to convert string-coded masks
+ * to `struct in_addr`.
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
  */
-uint8_t *ecrt_domain_data(
-        ec_domain_t *domain /**< Domain. */
+EC_PUBLIC_API int ecrt_slave_config_eoe_subnet_mask(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        struct in_addr subnet_mask /**< IPv4 subnet mask. */
         );
 
-/** Determines the states of the domain's datagrams.
+/** Sets the gateway address for Ethernet-over-EtherCAT (EoE) operation.
  *
- * Evaluates the working counters of the received datagrams and outputs
- * statistics, if necessary. This must be called after ecrt_master_receive()
- * is expected to receive the domain datagrams in order to make
- * ecrt_domain_state() return the result of the last process data exchange.
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * The gateway address is stored in the slave configuration object and will be
+ * written to the slave during the configuration process.
+ *
+ * The address is passed by-value as a `struct in_addr`. This structure
+ * contains the 32-bit IPv4 address in network byte order (big endian).
+ *
+ * See ecrt_slave_config_eoe_ip_address() on how to convert string-coded IPv4
+ * addresses to `struct in_addr`.
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
+ */
+EC_PUBLIC_API int ecrt_slave_config_eoe_default_gateway(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        struct in_addr gateway_address /**< Gateway's IPv4 address. */
+        );
+
+/** Sets the IPv4 address of the DNS server for Ethernet-over-EtherCAT (EoE)
+ * operation.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * The DNS server address is stored in the slave configuration object and will
+ * be written to the slave during the configuration process.
+ *
+ * The address is passed by-value as a `struct in_addr`. This structure
+ * contains the 32-bit IPv4 address in network byte order (big endian).
+ *
+ * See ecrt_slave_config_eoe_ip_address() on how to convert string-coded IPv4
+ * addresses to `struct in_addr`.
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
+ */
+EC_PUBLIC_API int ecrt_slave_config_eoe_dns_address(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        struct in_addr dns_address /**< IPv4 address of the DNS server. */
+        );
+
+/** Sets the host name for Ethernet-over-EtherCAT (EoE) operation.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * The host name is stored in the slave configuration object and will
+ * be written to the slave during the configuration process.
+ *
+ * The maximum size of the host name is 32 bytes (including the zero
+ * terminator).
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
+ */
+EC_PUBLIC_API int ecrt_slave_config_eoe_hostname(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        const char *name /**< Zero-terminated host name. */
+        );
+
+/** Sets the application-layer state transition timeout in ms.
+ *
+ * Change the maximum allowed time for a slave to make an application-layer
+ * state transition for the given state transition (for example from PREOP to
+ * SAFEOP). The default values are defined in ETG.2000.
+ *
+ * A timeout value of zero ms will restore the default value.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \retval  0 Success.
+ * \retval <0 Error code.
+ */
+EC_PUBLIC_API int ecrt_slave_config_state_timeout(
+        ec_slave_config_t *sc, /**< Slave configuration. */
+        ec_al_state_t from_state, /**< Initial state. */
+        ec_al_state_t to_state, /**< Target state. */
+        unsigned int timeout_ms /**< Timeout in [ms]. */
+        );
+
+/*****************************************************************************
+ * Domain methods
+ ****************************************************************************/
+
+/** Registers a bunch of PDO entries for a domain.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * \see ecrt_slave_config_reg_pdo_entry()
+ *
+ * \attention The registration array has to be terminated with an empty
+ *            structure, or one with the \a index field set to zero!
+ *
+ * \apiusage{master_idle,blocking}
+ *
+ * \return 0 on success, else non-zero.
+ */
+EC_PUBLIC_API int ecrt_domain_reg_pdo_entry_list(
+        ec_domain_t *domain, /**< Domain. */
+        const ec_pdo_entry_reg_t *pdo_entry_regs /**< Array of PDO
+                                                   registrations. */
+        );
+
+/** Returns the current size of the domain's process data.
+ *
+ * The domain size is calculated after master activation.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Size of the process data image, or a negative error code.
  */
-void ecrt_domain_process(
+EC_PUBLIC_API size_t ecrt_domain_size(
+        const ec_domain_t *domain /**< Domain. */
+        );
+
+#ifdef __KERNEL__
+
+/** Provide external memory to store the domain's process data.
+ *
+ * Call this after all PDO entries have been registered and before activating
+ * the master.
+ *
+ * The size of the allocated memory must be at least ecrt_domain_size(), after
+ * all PDO entries have been registered.
+ *
+ * This method has to be called in non-realtime context before
+ * ecrt_master_activate().
+ *
+ * \apiusage{master_idle,blocking}
+ */
+void ecrt_domain_external_memory(
+        ec_domain_t *domain, /**< Domain. */
+        uint8_t *memory /**< Address of the memory to store the process
+                          data in. */
+        );
+
+#endif /* __KERNEL__ */
+
+/** Returns the domain's process data.
+ *
+ * - In kernel context: If external memory was provided with
+ * ecrt_domain_external_memory(), the returned pointer will contain the
+ * address of that memory. Otherwise it will point to the internally allocated
+ * memory. In the latter case, this method may not be called before
+ * ecrt_master_activate().
+ *
+ * - In userspace context: This method has to be called after
+ * ecrt_master_activate() to get the mapped domain process data memory.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return Pointer to the process data memory.
+ */
+EC_PUBLIC_API uint8_t *ecrt_domain_data(
+        const ec_domain_t *domain /**< Domain. */
+        );
+
+/** Determines the states of the domain's datagrams.
+ *
+ * Evaluates the working counters of the received datagrams and outputs
+ * statistics, if necessary. This must be called after ecrt_master_receive()
+ * is expected to receive the domain datagrams in order to make
+ * ecrt_domain_state() return the result of the last process data exchange.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ */
+EC_PUBLIC_API int ecrt_domain_process(
         ec_domain_t *domain /**< Domain. */
         );
 
@@ -1703,8 +2239,12 @@ void ecrt_domain_process(
  *
  * Call this function to mark the domain's datagrams for exchanging at the
  * next call of ecrt_master_send().
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_domain_queue(
+EC_PUBLIC_API int ecrt_domain_queue(
         ec_domain_t *domain /**< Domain. */
         );
 
@@ -1713,8 +2253,12 @@ void ecrt_domain_queue(
  * Stores the domain state in the given \a state structure.
  *
  * Using this method, the process data exchange can be monitored in realtime.
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_domain_state(
+EC_PUBLIC_API int ecrt_domain_state(
         const ec_domain_t *domain, /**< Domain. */
         ec_domain_state_t *state /**< Pointer to a state object to store the
                                    information. */
@@ -1729,8 +2273,16 @@ void ecrt_domain_state(
  * \attention If the SDO index and/or subindex is changed while
  * ecrt_sdo_request_state() returns EC_REQUEST_BUSY, this may lead to
  * unexpected results.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation). To initialize the SDO request, the index and subindex can be
+ * set via ecrt_slave_config_create_sdo_request().
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_sdo_request_index(
+EC_PUBLIC_API int ecrt_sdo_request_index(
         ec_sdo_request_t *req, /**< SDO request. */
         uint16_t index, /**< SDO index. */
         uint8_t subindex /**< SDO subindex. */
@@ -1743,8 +2295,15 @@ void ecrt_sdo_request_index(
  *
  * The timeout is permanently stored in the request object and is valid until
  * the next call of this method.
+ *
+ * The timeout should be defined in non-realtime context, but can also be
+ * changed afterwards.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_sdo_request_timeout(
+EC_PUBLIC_API int ecrt_sdo_request_timeout(
         ec_sdo_request_t *req, /**< SDO request. */
         uint32_t timeout /**< Timeout in milliseconds. Zero means no
                            timeout. */
@@ -1754,8 +2313,8 @@ void ecrt_sdo_request_timeout(
  *
  * This function returns a pointer to the request's internal SDO data memory.
  *
- * - After a read operation was successful, integer data can be evaluated using
- *   the EC_READ_*() macros as usual. Example:
+ * - After a read operation was successful, integer data can be evaluated
+ *   using the EC_READ_*() macros as usual. Example:
  *   \code
  *   uint16_t value = EC_READ_U16(ecrt_sdo_request_data(sdo)));
  *   \endcode
@@ -1771,10 +2330,16 @@ void ecrt_sdo_request_timeout(
  * the internal SDO data memory could be re-allocated if the read SDO data do
  * not fit inside.
  *
+ * This method is meant to be called in realtime context (after master
+ * activation), but can also be used to initialize data before.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return Pointer to the internal SDO data memory.
+ *
  */
-uint8_t *ecrt_sdo_request_data(
-        ec_sdo_request_t *req /**< SDO request. */
+EC_PUBLIC_API uint8_t *ecrt_sdo_request_data(
+        const ec_sdo_request_t *req /**< SDO request. */
         );
 
 /** Returns the current SDO data size.
@@ -1783,32 +2348,54 @@ uint8_t *ecrt_sdo_request_data(
  * reserved memory. After a read operation the size is set to the size of the
  * read data. The size is not modified in any other situation.
  *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return SDO data size in bytes.
+ *
  */
-size_t ecrt_sdo_request_data_size(
+EC_PUBLIC_API size_t ecrt_sdo_request_data_size(
         const ec_sdo_request_t *req /**< SDO request. */
         );
 
 /** Get the current state of the SDO request.
+ *
+ * The user-space implementation fetches incoming data and stores the received
+ * data size in the request object, so the request is not const.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
  *
  * \return Request state.
+ *
  */
+EC_PUBLIC_API ec_request_state_t ecrt_sdo_request_state(
 #ifdef __KERNEL__
-ec_request_state_t ecrt_sdo_request_state(
-        const ec_sdo_request_t *req /**< SDO request. */
-    );
-#else
-ec_request_state_t ecrt_sdo_request_state(
-        ec_sdo_request_t *req /**< SDO request. */
-    );
+        const
 #endif
+        ec_sdo_request_t *req /**< SDO request. */
+        );
 
 /** Schedule an SDO write operation.
  *
  * \attention This method may not be called while ecrt_sdo_request_state()
  * returns EC_REQUEST_BUSY.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval -EINVAL Invalid input data, e.g. data size == 0.
+ * \retval -ENOBUFS Reserved memory in ecrt_slave_config_create_sdo_request()
+ *              too small.
  */
-void ecrt_sdo_request_write(
+EC_PUBLIC_API int ecrt_sdo_request_write(
         ec_sdo_request_t *req /**< SDO request. */
         );
 
@@ -1820,11 +2407,168 @@ void ecrt_sdo_request_write(
  * \attention After calling this function, the return value of
  * ecrt_sdo_request_data() must be considered as invalid while
  * ecrt_sdo_request_state() returns EC_REQUEST_BUSY.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_sdo_request_read(
+EC_PUBLIC_API int ecrt_sdo_request_read(
         ec_sdo_request_t *req /**< SDO request. */
         );
 
+/*****************************************************************************
+ * SoE request methods.
+ ****************************************************************************/
+
+/** Set the request's drive and Sercos ID numbers.
+ *
+ * \attention If the drive number and/or IDN is changed while
+ * ecrt_soe_request_state() returns EC_REQUEST_BUSY, this may lead to
+ * unexpected results.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation). To initialize the SoE request, the drive_no and IDN can be
+ * set via ecrt_slave_config_create_soe_request().
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ */
+EC_PUBLIC_API int ecrt_soe_request_idn(
+        ec_soe_request_t *req, /**< IDN request. */
+        uint8_t drive_no, /**< SDO index. */
+        uint16_t idn /**< SoE IDN. */
+        );
+
+/** Set the timeout for an SoE request.
+ *
+ * If the request cannot be processed in the specified time, if will be marked
+ * as failed.
+ *
+ * The timeout is permanently stored in the request object and is valid until
+ * the next call of this method.
+ *
+ * The timeout should be defined in non-realtime context, but can also be
+ * changed afterwards.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ */
+EC_PUBLIC_API int ecrt_soe_request_timeout(
+        ec_soe_request_t *req, /**< SoE request. */
+        uint32_t timeout /**< Timeout in milliseconds. Zero means no
+                           timeout. */
+        );
+
+/** Access to the SoE request's data.
+ *
+ * This function returns a pointer to the request's internal IDN data memory.
+ *
+ * - After a read operation was successful, integer data can be evaluated
+ *   using the EC_READ_*() macros as usual. Example:
+ *   \code
+ *   uint16_t value = EC_READ_U16(ecrt_soe_request_data(idn_req)));
+ *   \endcode
+ * - If a write operation shall be triggered, the data have to be written to
+ *   the internal memory. Use the EC_WRITE_*() macros, if you are writing
+ *   integer data. Be sure, that the data fit into the memory. The memory size
+ *   is a parameter of ecrt_slave_config_create_soe_request().
+ *   \code
+ *   EC_WRITE_U16(ecrt_soe_request_data(idn_req), 0xFFFF);
+ *   \endcode
+ *
+ * \attention The return value can be invalidated during a read operation,
+ * because the internal IDN data memory could be re-allocated if the read IDN
+ * data do not fit inside.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation), but can also be used to initialize data before.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return Pointer to the internal IDN data memory.
+ *
+ */
+EC_PUBLIC_API uint8_t *ecrt_soe_request_data(
+        const ec_soe_request_t *req /**< SoE request. */
+        );
+
+/** Returns the current IDN data size.
+ *
+ * When the SoE request is created, the data size is set to the size of the
+ * reserved memory. After a read operation the size is set to the size of the
+ * read data. The size is not modified in any other situation.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return IDN data size in bytes.
+ */
+EC_PUBLIC_API size_t ecrt_soe_request_data_size(
+        const ec_soe_request_t *req /**< SoE request. */
+        );
+
+/** Get the current state of the SoE request.
+ *
+ * \return Request state.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * In the user-space implementation, the method fetches the size of the
+ * incoming data, so the request object is not const.
+ *
+ * \apiusage{master_op,rt_safe}
+ */
+EC_PUBLIC_API ec_request_state_t ecrt_soe_request_state(
+#ifdef __KERNEL__
+        const
+#endif
+        ec_soe_request_t *req /**< SoE request. */
+        );
+
+/** Schedule an SoE IDN write operation.
+ *
+ * \attention This method may not be called while ecrt_soe_request_state()
+ * returns EC_REQUEST_BUSY.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval -EINVAL Invalid input data, e.g. data size == 0.
+ * \retval -ENOBUFS Reserved memory in ecrt_slave_config_create_soe_request()
+ *              too small.
+ */
+EC_PUBLIC_API int ecrt_soe_request_write(
+        ec_soe_request_t *req /**< SoE request. */
+        );
+
+/** Schedule an SoE IDN read operation.
+ *
+ * \attention This method may not be called while ecrt_soe_request_state()
+ * returns EC_REQUEST_BUSY.
+ *
+ * \attention After calling this function, the return value of
+ * ecrt_soe_request_data() must be considered as invalid while
+ * ecrt_soe_request_state() returns EC_REQUEST_BUSY.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ */
+EC_PUBLIC_API int ecrt_soe_request_read(
+        ec_soe_request_t *req /**< SoE request. */
+        );
+
 /*****************************************************************************
  * VoE handler methods.
  ****************************************************************************/
@@ -1835,8 +2579,16 @@ void ecrt_sdo_request_read(
  * type at as header. These numbers can be set with this function. The values
  * are valid and will be used for future send operations until the next call
  * of this method.
+ *
+ * This method is meant to be called in non-realtime context (before master
+ * activation) to initialize the header data, but it is also safe to
+ * change the header later on in realtime context.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_voe_handler_send_header(
+EC_PUBLIC_API int ecrt_voe_handler_send_header(
         ec_voe_handler_t *voe, /**< VoE handler. */
         uint32_t vendor_id, /**< Vendor ID. */
         uint16_t vendor_type /**< Vendor-specific type. */
@@ -1849,8 +2601,15 @@ void ecrt_voe_handler_send_header(
  *
  * The header information is stored at the memory given by the pointer
  * parameters.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_voe_handler_received_header(
+EC_PUBLIC_API int ecrt_voe_handler_received_header(
         const ec_voe_handler_t *voe, /**< VoE handler. */
         uint32_t *vendor_id, /**< Vendor ID. */
         uint16_t *vendor_type /**< Vendor-specific type. */
@@ -1874,10 +2633,12 @@ void ecrt_voe_handler_received_header(
  * avoided by reserving enough memory via the \a size parameter of
  * ecrt_slave_config_create_voe_handler().
  *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return Pointer to the internal memory.
  */
-uint8_t *ecrt_voe_handler_data(
-        ec_voe_handler_t *voe /**< VoE handler. */
+EC_PUBLIC_API uint8_t *ecrt_voe_handler_data(
+        const ec_voe_handler_t *voe /**< VoE handler. */
         );
 
 /** Returns the current data size.
@@ -1890,19 +2651,31 @@ uint8_t *ecrt_voe_handler_data(
  * of bytes to write. After a read operation the size is set to the size of
  * the read data. The size is not modified in any other situation.
  *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return Data size in bytes.
  */
-size_t ecrt_voe_handler_data_size(
+EC_PUBLIC_API size_t ecrt_voe_handler_data_size(
         const ec_voe_handler_t *voe /**< VoE handler. */
         );
 
 /** Start a VoE write operation.
  *
  * After this function has been called, the ecrt_voe_handler_execute() method
- * must be called in every bus cycle as long as it returns EC_REQUEST_BUSY. No
- * other operation may be started while the handler is busy.
+ * must be called in every realtime cycle as long as it returns
+ * EC_REQUEST_BUSY. No other operation may be started while the handler is
+ * busy.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval -ENOBUFS Reserved memory in ecrt_slave_config_create_voe_handler
+ *                  too small.
  */
-void ecrt_voe_handler_write(
+EC_PUBLIC_API int ecrt_voe_handler_write(
         ec_voe_handler_t *voe, /**< VoE handler. */
         size_t size /**< Number of bytes to write (without the VoE header). */
         );
@@ -1910,8 +2683,9 @@ void ecrt_voe_handler_write(
 /** Start a VoE read operation.
  *
  * After this function has been called, the ecrt_voe_handler_execute() method
- * must be called in every bus cycle as long as it returns EC_REQUEST_BUSY. No
- * other operation may be started while the handler is busy.
+ * must be called in every realtime cycle as long as it returns
+ * EC_REQUEST_BUSY. No other operation may be started while the handler is
+ * busy.
  *
  * The state machine queries the slave's send mailbox for new data to be send
  * to the master. If no data appear within the EC_VOE_RESPONSE_TIMEOUT
@@ -1920,16 +2694,24 @@ void ecrt_voe_handler_write(
  * On success, the size of the read data can be determined via
  * ecrt_voe_handler_data_size(), while the VoE header of the received data
  * can be retrieved with ecrt_voe_handler_received_header().
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_voe_handler_read(
+EC_PUBLIC_API int ecrt_voe_handler_read(
         ec_voe_handler_t *voe /**< VoE handler. */
         );
 
 /** Start a VoE read operation without querying the sync manager status.
  *
  * After this function has been called, the ecrt_voe_handler_execute() method
- * must be called in every bus cycle as long as it returns EC_REQUEST_BUSY. No
- * other operation may be started while the handler is busy.
+ * must be called in every realtime cycle as long as it returns
+ * EC_REQUEST_BUSY. No other operation may be started while the handler is
+ * busy.
  *
  * The state machine queries the slave by sending an empty mailbox. The slave
  * fills its data to the master in this mailbox. If no data appear within the
@@ -1939,21 +2721,34 @@ void ecrt_voe_handler_read(
  * On success, the size of the read data can be determined via
  * ecrt_voe_handler_data_size(), while the VoE header of the received data
  * can be retrieved with ecrt_voe_handler_received_header().
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
  */
-void ecrt_voe_handler_read_nosync(
+EC_PUBLIC_API int ecrt_voe_handler_read_nosync(
         ec_voe_handler_t *voe /**< VoE handler. */
         );
 
 /** Execute the handler.
  *
- * This method executes the VoE handler. It has to be called in every bus
+ * This method executes the VoE handler. It has to be called in every realtime
  * cycle as long as it returns EC_REQUEST_BUSY.
  *
  * \return Handler state.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
  */
-ec_request_state_t ecrt_voe_handler_execute(
-    ec_voe_handler_t *voe /**< VoE handler. */
-    );
+EC_PUBLIC_API ec_request_state_t ecrt_voe_handler_execute(
+        ec_voe_handler_t *voe /**< VoE handler. */
+        );
 
 /*****************************************************************************
  * Register request methods.
@@ -1976,25 +2771,31 @@ ec_request_state_t ecrt_voe_handler_execute(
  *   EC_WRITE_U16(ecrt_reg_request_data(reg_request), 0xFFFF);
  *   \endcode
  *
+ * This method is meant to be called in realtime context (after master
+ * activation), but can also be used to initialize data before.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
  * \return Pointer to the internal memory.
+ *
  */
-uint8_t *ecrt_reg_request_data(
-        ec_reg_request_t *req /**< Register request. */
+EC_PUBLIC_API uint8_t *ecrt_reg_request_data(
+        const ec_reg_request_t *req /**< Register request. */
         );
 
 /** Get the current state of the register request.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
  *
  * \return Request state.
+ *
  */
-#ifdef __KERNEL__
-ec_request_state_t ecrt_reg_request_state(
+EC_PUBLIC_API ec_request_state_t ecrt_reg_request_state(
         const ec_reg_request_t *req /**< Register request. */
     );
-#else
-ec_request_state_t ecrt_reg_request_state(
-        ec_reg_request_t *req /**< Register request. */
-    );
-#endif
 
 /** Schedule an register write operation.
  *
@@ -2003,8 +2804,17 @@ ec_request_state_t ecrt_reg_request_state(
  *
  * \attention The \a size parameter is truncated to the size given at request
  * creation.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval -ENOBUFS Reserved memory in ecrt_slave_config_create_reg_request
+ *              too small.
  */
-void ecrt_reg_request_write(
+EC_PUBLIC_API int ecrt_reg_request_write(
         ec_reg_request_t *req, /**< Register request. */
         uint16_t address, /**< Register address. */
         size_t size /**< Size to write. */
@@ -2017,27 +2827,25 @@ void ecrt_reg_request_write(
  *
  * \attention The \a size parameter is truncated to the size given at request
  * creation.
+ *
+ * This method is meant to be called in realtime context (after master
+ * activation).
+ *
+ * \apiusage{master_op,rt_safe}
+ *
+ * \return 0 on success, otherwise negative error code.
+ * \retval -ENOBUFS Reserved memory in ecrt_slave_config_create_reg_request
+ *              too small.
  */
-void ecrt_reg_request_read(
+EC_PUBLIC_API int ecrt_reg_request_read(
         ec_reg_request_t *req, /**< Register request. */
         uint16_t address, /**< Register address. */
         size_t size /**< Size to write. */
         );
 
-
-
-int ecrt_domain_received( ec_domain_t *domain );
-
-
-/*****************************************************************************/
-
-#ifdef __cplusplus
-}
-#endif
-
-/******************************************************************************
+/*****************************************************************************
  * Bitwise read/write macros
- *****************************************************************************/
+ ****************************************************************************/
 
 /** Read a certain bit of an EtherCAT data byte.
  *
@@ -2058,9 +2866,9 @@ int ecrt_domain_received( ec_domain_t *domain );
         else     *((uint8_t *) (DATA)) &= ~(1 << (POS)); \
     } while (0)
 
-/******************************************************************************
+/*****************************************************************************
  * Byte-swapping functions for user space
- *****************************************************************************/
+ ****************************************************************************/
 
 #ifndef __KERNEL__
 
@@ -2113,9 +2921,9 @@ int ecrt_domain_received( ec_domain_t *domain );
 
 #endif /* ifndef __KERNEL__ */
 
-/******************************************************************************
+/*****************************************************************************
  * Read macros
- *****************************************************************************/
+ ****************************************************************************/
 
 /** Read an 8-bit unsigned value from EtherCAT data.
  *
@@ -2180,9 +2988,49 @@ int ecrt_domain_received( ec_domain_t *domain );
 #define EC_READ_S64(DATA) \
      ((int64_t) le64_to_cpup((void *) (DATA)))
 
-/******************************************************************************
+/*****************************************************************************
+ * Floating-point read functions and macros (userspace only)
+ ****************************************************************************/
+
+#ifndef __KERNEL__
+
+/** Read a 32-bit floating-point value from EtherCAT data.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \param data EtherCAT data pointer
+ * \return EtherCAT data value
+ */
+EC_PUBLIC_API float ecrt_read_real(const void *data);
+
+/** Read a 32-bit floating-point value from EtherCAT data.
+ *
+ * \param DATA EtherCAT data pointer
+ * \return EtherCAT data value
+ */
+#define EC_READ_REAL(DATA) ecrt_read_real(DATA)
+
+/** Read a 64-bit floating-point value from EtherCAT data.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \param data EtherCAT data pointer
+ * \return EtherCAT data value
+ */
+EC_PUBLIC_API double ecrt_read_lreal(const void *data);
+
+/** Read a 64-bit floating-point value from EtherCAT data.
+ *
+ * \param DATA EtherCAT data pointer
+ * \return EtherCAT data value
+ */
+#define EC_READ_LREAL(DATA) ecrt_read_lreal(DATA)
+
+#endif // ifndef __KERNEL__
+
+/*****************************************************************************
  * Write macros
- *****************************************************************************/
+ ****************************************************************************/
 
 /** Write an 8-bit unsigned value to EtherCAT data.
  *
@@ -2252,7 +3100,53 @@ int ecrt_domain_received( ec_domain_t *domain );
  */
 #define EC_WRITE_S64(DATA, VAL) EC_WRITE_U64(DATA, VAL)
 
-/*****************************************************************************/
+/*****************************************************************************
+ * Floating-point write functions and macros (userspace only)
+ ****************************************************************************/
+
+#ifndef __KERNEL__
+
+/** Write a 32-bit floating-point value to EtherCAT data.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \param data EtherCAT data pointer
+ * \param value new value
+ */
+EC_PUBLIC_API void ecrt_write_real(void *data, float value);
+
+/** Write a 32-bit floating-point value to EtherCAT data.
+ *
+ * \param DATA EtherCAT data pointer
+ * \param VAL new value
+ */
+#define EC_WRITE_REAL(DATA, VAL) ecrt_write_real(DATA, VAL)
+
+/** Write a 64-bit floating-point value to EtherCAT data.
+ *
+ * \apiusage{master_any,rt_safe}
+ *
+ * \param data EtherCAT data pointer
+ * \param value new value
+ */
+EC_PUBLIC_API void ecrt_write_lreal(void *data, double value);
+
+/** Write a 64-bit floating-point value to EtherCAT data.
+ *
+ * \param DATA EtherCAT data pointer
+ * \param VAL new value
+ */
+#define EC_WRITE_LREAL(DATA, VAL) ecrt_write_lreal(DATA, VAL)
+
+#endif // ifndef __KERNEL__
+
+/****************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+/****************************************************************************/
 
 /** @} */
 
