#!/usr/bin/awk -f
# generate_pdo_map.awk
# Reads an IgH `ethercat cstruct` dump from stdin and writes a complete pdo_map.h to stdout.
#
# Run:
#   awk -v VENDOR=0x0000006c -v PRODUCT=0x0000a72c -v POS=0 -f generate_pdo_map.awk cstruct.txt > pdo_map.h
#
# Notes:
# - Expects a single big ec_pdo_entry_info_t array and an ec_pdo_info_t array with offsets like:
#     ec_pdo_entry_info_t slave_..._pdo_entries[] = { {0x3000,0x01,8}, ... };
#     ec_pdo_info_t slave_..._pdos[] = {
#         {0x1600, 200, slave_..._pdo_entries + 0},
#         {0x1601,  50, slave_..._pdo_entries + 200},
#         {0x1A00, 200, slave_..._pdo_entries + 250},
#         {0x1A01,  50, slave_..._pdo_entries + 450},
#     };
#
# - Produces arrays:
#     RXPDO_1600_ENTRIES[], RXPDO_1601_ENTRIES[],
#     TXPDO_1A00_ENTRIES[], TXPDO_1A01_ENTRIES[].

BEGIN {
  # Defaults (can be overridden with -v VENDOR=..., etc.)
  if (VENDOR  == "") VENDOR  = "0x0000006c"
  if (PRODUCT == "") PRODUCT = "0x0000a72c"
  if (POS     == "") POS     = "0"

  # Internal state
  in_entries = 0
  in_pdos    = 0
  n_flat     = 0
  n_pdos     = 0

  # Which PDOs do we care about:
  targetPDOs["0x1600"] = 1
  targetPDOs["0x1601"] = 1
  targetPDOs["0x1A00"] = 1
  targetPDOs["0x1A01"] = 1
}

# Detect start of the flat entry array
/^[[:space:]]*ec_pdo_entry_info_t[[:space:]].*\[[[:space:]]*\][[:space:]]*=[[:space:]]*\{/ {
  in_entries = 1
  next
}

# Detect end of the flat entry array
in_entries && /\};/ {
  in_entries = 0
  next
}

# Capture each flat entry row within entry array
in_entries {
  # Match lines like: {0x3000, 0x01, 8},  possibly with comments/spaces
  # Allow hex in upper/lower case.
  if (match($0, /\{\s*0x([0-9A-Fa-f]+)\s*,\s*0x([0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*\}/, m)) {
    idx_hex = "0x" m[1]
    sub_hex = "0x" m[2]
    bits    =  m[3] + 0
    # Store in order
    idx_arr[n_flat] = idx_hex
    sub_arr[n_flat] = sub_hex
    bit_arr[n_flat] = bits
    n_flat++
  }
  next
}

# Detect start of pdo info array
/^[[:space:]]*ec_pdo_info_t[[:space:]].*\[[[:space:]]*\][[:space:]]*=[[:space:]]*\{/ {
  in_pdos = 1
  next
}

# Detect end of pdo info array
in_pdos && /\};/ {
  in_pdos = 0
  next
}

# Capture each PDO info row
in_pdos {
  # Match lines like: {0x1600, 200, slave_... + 0},
  # Captures PDO index (hex), count (dec), offset (dec)
  if (match($0, /\{\s*0x([0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*,[^+]+\+\s*([0-9]+)\s*\}/, m)) {
    pidx_hex = sprintf("0x%04X", strtonum("0x" m[1]))
    cnt      = m[2] + 0
    off      = m[3] + 0

    pdo_idx_hex[n_pdos] = pidx_hex
    pdo_cnt[n_pdos]     = cnt
    pdo_off[n_pdos]     = off
    n_pdos++

    # If one of our target PDOs, record its start & count
    if (targetPDOs[pidx_hex]) {
      want_off[pidx_hex] = off
      want_cnt[pidx_hex] = cnt
    }
  }
  next
}

END {
  # Basic sanity
  if (n_flat == 0) {
    print "ERROR: Did not find any ec_pdo_entry_info_t entries in input!" > "/dev/stderr"
    exit 1
  }
  if (n_pdos == 0) {
    print "ERROR: Did not find any ec_pdo_info_t PDO list in input!" > "/dev/stderr"
    exit 1
  }

  # Print header
  print "#pragma once"
  print "#include <ecrt.h>"
  print ""
  print "/* Generated by generate_pdo_map.awk */"
  print ""
  printf("#define VENDOR_ID    %s\n", VENDOR)
  printf("#define PRODUCT_CODE %s\n", PRODUCT)
  printf("#define SLAVE_POS    %s\n", POS)
  print ""

  # Helper to emit one PDO array by PDO index
  # (implemented inline using awk function-like blocks)
  # We'll call this logic 4 times for 0x1600, 0x1601, 0x1A00, 0x1A01
  function emit_array(pdo_hex, arr_name,   start, count, i, k, idx, sub, bits) {
    if (!(pdo_hex in want_off)) {
      printf("/* WARNING: PDO %s not found in cstruct PDO list. */\n", pdo_hex)
      printf("static const ec_pdo_entry_info_t %s[] = { /* empty */ };\n\n", arr_name)
      return
    }
    start = want_off[pdo_hex]
    count = want_cnt[pdo_hex]
    printf("/* ---- %s entries (from cstruct) ---- */\n", pdo_hex)
    printf("static const ec_pdo_entry_info_t %s[] = {\n", arr_name)
    for (k = 0; k < count; k++) {
      i = start + k
      idx = idx_arr[i]; sub = sub_arr[i]; bits = bit_arr[i]
      # Normalize hex formatting
      idx_num = strtonum(idx)
      sub_num = strtonum(sub)
      printf("    {0x%04X, 0x%02X, %d}%s\n",
             idx_num, sub_num, bits, (k+1<count ? "," : ""))
    }
    print "};\n"
  }

  # Emit the four arrays
  emit_array("0x1600", "RXPDO_1600_ENTRIES")
  emit_array("0x1601", "RXPDO_1601_ENTRIES")
  emit_array("0x1A00", "TXPDO_1A00_ENTRIES")
  emit_array("0x1A01", "TXPDO_1A01_ENTRIES")

  # Counts
  print "#define ARRAY_LEN(a) ((int)(sizeof(a) / sizeof((a)[0])))"
  print ""
  print "enum {"
  print "    RXPDO_1600_COUNT = ARRAY_LEN(RXPDO_1600_ENTRIES),"
  print "    RXPDO_1601_COUNT = ARRAY_LEN(RXPDO_1601_ENTRIES),"
  print "    TXPDO_1A00_COUNT = ARRAY_LEN(TXPDO_1A00_ENTRIES),"
  print "    TXPDO_1A01_COUNT = ARRAY_LEN(TXPDO_1A01_ENTRIES),"
  print "};"
  print ""
  print "#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)"
  print "_Static_assert(RXPDO_1600_COUNT > 0, \"0x1600 entries missing\");"
  print "_Static_assert(RXPDO_1601_COUNT > 0, \"0x1601 entries missing\");"
  print "_Static_assert(TXPDO_1A00_COUNT > 0, \"0x1A00 entries missing\");"
  print "_Static_assert(TXPDO_1A01_COUNT > 0, \"0x1A01 entries missing\");"
  print "#endif"
  print ""

  # RX_PDOS / TX_PDOS
  print "static const ec_pdo_info_t RX_PDOS[] = {"
  print "    { 0x1600, RXPDO_1600_COUNT, RXPDO_1600_ENTRIES },"
  print "    { 0x1601, RXPDO_1601_COUNT, RXPDO_1601_ENTRIES },"
  print "};"
  print ""
  print "static const ec_pdo_info_t TX_PDOS[] = {"
  print "    { 0x1A00, TXPDO_1A00_COUNT, TXPDO_1A00_ENTRIES },"
  print "    { 0x1A01, TXPDO_1A01_COUNT, TXPDO_1A01_ENTRIES },"
  print "};"
  print ""

  # Syncs
  print "static const ec_sync_info_t SLAVE_SYNC_INFO[] = {"
  print "    { 0, EC_DIR_OUTPUT, 0, NULL,          EC_WD_DISABLE },"
  print "    { 1, EC_DIR_INPUT,  0, NULL,          EC_WD_DISABLE },"
  print "    { 2, EC_DIR_OUTPUT, (uint8_t)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])), RX_PDOS, EC_WD_DISABLE },"
  print "    { 3, EC_DIR_INPUT,  (uint8_t)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])), TX_PDOS, EC_WD_DISABLE },"
  print "    { 0xFF, 0, 0, NULL, EC_WD_DISABLE }"
  print "};"
  print ""

  # build_entry_regs + total_rx_entries
  print "static inline int build_entry_regs(ec_pdo_entry_reg_t **out_regs, unsigned **out_offsets, int *out_total)"
  print "{"
  print "    int total = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) total += RX_PDOS[p].n_entries;"
  print "    for (int p=0; p<(int)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])); p++) total += TX_PDOS[p].n_entries;"
  print ""
  print "    ec_pdo_entry_reg_t *regs = calloc((size_t)total + 1, sizeof(*regs));"
  print "    unsigned *offs = calloc((size_t)total, sizeof(*offs));"
  print "    if (!regs || !offs) return -1;"
  print ""
  print "    int k = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) {"
  print "        const ec_pdo_info_t *pdo = &RX_PDOS[p];"
  print "        for (int e=0; e<pdo->n_entries; e++, k++) {"
  print "            regs[k].alias        = 0;"
  print "            regs[k].position     = SLAVE_POS;"
  print "            regs[k].vendor_id    = VENDOR_ID;"
  print "            regs[k].product_code = PRODUCT_CODE;"
  print "            regs[k].index        = pdo->entries[e].index;"
  print "            regs[k].subindex     = pdo->entries[e].subindex;"
  print "            regs[k].offset       = &offs[k];"
  print "        }"
  print "    }"
  print "    for (int p=0; p<(int)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])); p++) {"
  print "        const ec_pdo_info_t *pdo = &TX_PDOS[p];"
  print "        for (int e=0; e<pdo->n_entries; e++, k++) {"
  print "            regs[k].alias        = 0;"
  print "            regs[k].position     = SLAVE_POS;"
  print "            regs[k].vendor_id    = VENDOR_ID;"
  print "            regs[k].product_code = PRODUCT_CODE;"
  print "            regs[k].index        = pdo->entries[e].index;"
  print "            regs[k].subindex     = pdo->entries[e].subindex;"
  print "            regs[k].offset       = &offs[k];"
  print "        }"
  print "    }"
  print "    regs[k] = (ec_pdo_entry_reg_t){0};"
  print "    *out_regs = regs; *out_offsets = offs; *out_total = total;"
  print "    return 0;"
  print "}"
  print ""
  print "static inline int total_rx_entries(void)"
  print "{"
  print "    int n = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) n += RX_PDOS[p].n_entries;"
  print "    return n;"
  print "}"
}#!/usr/bin/awk -f
# generate_pdo_map.awk
# Reads an IgH `ethercat cstruct` dump from stdin and writes a complete pdo_map.h to stdout.
#
# Run:
#   awk -v VENDOR=0x0000006c -v PRODUCT=0x0000a72c -v POS=0 -f generate_pdo_map.awk cstruct.txt > pdo_map.h
#
# Notes:
# - Expects a single big ec_pdo_entry_info_t array and an ec_pdo_info_t array with offsets like:
#     ec_pdo_entry_info_t slave_..._pdo_entries[] = { {0x3000,0x01,8}, ... };
#     ec_pdo_info_t slave_..._pdos[] = {
#         {0x1600, 200, slave_..._pdo_entries + 0},
#         {0x1601,  50, slave_..._pdo_entries + 200},
#         {0x1A00, 200, slave_..._pdo_entries + 250},
#         {0x1A01,  50, slave_..._pdo_entries + 450},
#     };
#
# - Produces arrays:
#     RXPDO_1600_ENTRIES[], RXPDO_1601_ENTRIES[],
#     TXPDO_1A00_ENTRIES[], TXPDO_1A01_ENTRIES[].

BEGIN {
  # Defaults (can be overridden with -v VENDOR=..., etc.)
  if (VENDOR  == "") VENDOR  = "0x0000006c"
  if (PRODUCT == "") PRODUCT = "0x0000a72c"
  if (POS     == "") POS     = "0"

  # Internal state
  in_entries = 0
  in_pdos    = 0
  n_flat     = 0
  n_pdos     = 0

  # Which PDOs do we care about:
  targetPDOs["0x1600"] = 1
  targetPDOs["0x1601"] = 1
  targetPDOs["0x1A00"] = 1
  targetPDOs["0x1A01"] = 1
}

# Detect start of the flat entry array
/^[[:space:]]*ec_pdo_entry_info_t[[:space:]].*\[[[:space:]]*\][[:space:]]*=[[:space:]]*\{/ {
  in_entries = 1
  next
}

# Detect end of the flat entry array
in_entries && /\};/ {
  in_entries = 0
  next
}

# Capture each flat entry row within entry array
in_entries {
  # Match lines like: {0x3000, 0x01, 8},  possibly with comments/spaces
  # Allow hex in upper/lower case.
  if (match($0, /\{\s*0x([0-9A-Fa-f]+)\s*,\s*0x([0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*\}/, m)) {
    idx_hex = "0x" m[1]
    sub_hex = "0x" m[2]
    bits    =  m[3] + 0
    # Store in order
    idx_arr[n_flat] = idx_hex
    sub_arr[n_flat] = sub_hex
    bit_arr[n_flat] = bits
    n_flat++
  }
  next
}

# Detect start of pdo info array
/^[[:space:]]*ec_pdo_info_t[[:space:]].*\[[[:space:]]*\][[:space:]]*=[[:space:]]*\{/ {
  in_pdos = 1
  next
}

# Detect end of pdo info array
in_pdos && /\};/ {
  in_pdos = 0
  next
}

# Capture each PDO info row
in_pdos {
  # Match lines like: {0x1600, 200, slave_... + 0},
  # Captures PDO index (hex), count (dec), offset (dec)
  if (match($0, /\{\s*0x([0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*,[^+]+\+\s*([0-9]+)\s*\}/, m)) {
    pidx_hex = sprintf("0x%04X", strtonum("0x" m[1]))
    cnt      = m[2] + 0
    off      = m[3] + 0

    pdo_idx_hex[n_pdos] = pidx_hex
    pdo_cnt[n_pdos]     = cnt
    pdo_off[n_pdos]     = off
    n_pdos++

    # If one of our target PDOs, record its start & count
    if (targetPDOs[pidx_hex]) {
      want_off[pidx_hex] = off
      want_cnt[pidx_hex] = cnt
    }
  }
  next
}

END {
  # Basic sanity
  if (n_flat == 0) {
    print "ERROR: Did not find any ec_pdo_entry_info_t entries in input!" > "/dev/stderr"
    exit 1
  }
  if (n_pdos == 0) {
    print "ERROR: Did not find any ec_pdo_info_t PDO list in input!" > "/dev/stderr"
    exit 1
  }

  # Print header
  print "#pragma once"
  print "#include <ecrt.h>"
  print ""
  print "/* Generated by generate_pdo_map.awk */"
  print ""
  printf("#define VENDOR_ID    %s\n", VENDOR)
  printf("#define PRODUCT_CODE %s\n", PRODUCT)
  printf("#define SLAVE_POS    %s\n", POS)
  print ""

  # Helper to emit one PDO array by PDO index
  # (implemented inline using awk function-like blocks)
  # We'll call this logic 4 times for 0x1600, 0x1601, 0x1A00, 0x1A01
  function emit_array(pdo_hex, arr_name,   start, count, i, k, idx, sub, bits) {
    if (!(pdo_hex in want_off)) {
      printf("/* WARNING: PDO %s not found in cstruct PDO list. */\n", pdo_hex)
      printf("static const ec_pdo_entry_info_t %s[] = { /* empty */ };\n\n", arr_name)
      return
    }
    start = want_off[pdo_hex]
    count = want_cnt[pdo_hex]
    printf("/* ---- %s entries (from cstruct) ---- */\n", pdo_hex)
    printf("static const ec_pdo_entry_info_t %s[] = {\n", arr_name)
    for (k = 0; k < count; k++) {
      i = start + k
      idx = idx_arr[i]; sub = sub_arr[i]; bits = bit_arr[i]
      # Normalize hex formatting
      idx_num = strtonum(idx)
      sub_num = strtonum(sub)
      printf("    {0x%04X, 0x%02X, %d}%s\n",
             idx_num, sub_num, bits, (k+1<count ? "," : ""))
    }
    print "};\n"
  }

  # Emit the four arrays
  emit_array("0x1600", "RXPDO_1600_ENTRIES")
  emit_array("0x1601", "RXPDO_1601_ENTRIES")
  emit_array("0x1A00", "TXPDO_1A00_ENTRIES")
  emit_array("0x1A01", "TXPDO_1A01_ENTRIES")

  # Counts
  print "#define ARRAY_LEN(a) ((int)(sizeof(a) / sizeof((a)[0])))"
  print ""
  print "enum {"
  print "    RXPDO_1600_COUNT = ARRAY_LEN(RXPDO_1600_ENTRIES),"
  print "    RXPDO_1601_COUNT = ARRAY_LEN(RXPDO_1601_ENTRIES),"
  print "    TXPDO_1A00_COUNT = ARRAY_LEN(TXPDO_1A00_ENTRIES),"
  print "    TXPDO_1A01_COUNT = ARRAY_LEN(TXPDO_1A01_ENTRIES),"
  print "};"
  print ""
  print "#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)"
  print "_Static_assert(RXPDO_1600_COUNT > 0, \"0x1600 entries missing\");"
  print "_Static_assert(RXPDO_1601_COUNT > 0, \"0x1601 entries missing\");"
  print "_Static_assert(TXPDO_1A00_COUNT > 0, \"0x1A00 entries missing\");"
  print "_Static_assert(TXPDO_1A01_COUNT > 0, \"0x1A01 entries missing\");"
  print "#endif"
  print ""

  # RX_PDOS / TX_PDOS
  print "static const ec_pdo_info_t RX_PDOS[] = {"
  print "    { 0x1600, RXPDO_1600_COUNT, RXPDO_1600_ENTRIES },"
  print "    { 0x1601, RXPDO_1601_COUNT, RXPDO_1601_ENTRIES },"
  print "};"
  print ""
  print "static const ec_pdo_info_t TX_PDOS[] = {"
  print "    { 0x1A00, TXPDO_1A00_COUNT, TXPDO_1A00_ENTRIES },"
  print "    { 0x1A01, TXPDO_1A01_COUNT, TXPDO_1A01_ENTRIES },"
  print "};"
  print ""

  # Syncs
  print "static const ec_sync_info_t SLAVE_SYNC_INFO[] = {"
  print "    { 0, EC_DIR_OUTPUT, 0, NULL,          EC_WD_DISABLE },"
  print "    { 1, EC_DIR_INPUT,  0, NULL,          EC_WD_DISABLE },"
  print "    { 2, EC_DIR_OUTPUT, (uint8_t)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])), RX_PDOS, EC_WD_DISABLE },"
  print "    { 3, EC_DIR_INPUT,  (uint8_t)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])), TX_PDOS, EC_WD_DISABLE },"
  print "    { 0xFF, 0, 0, NULL, EC_WD_DISABLE }"
  print "};"
  print ""

  # build_entry_regs + total_rx_entries
  print "static inline int build_entry_regs(ec_pdo_entry_reg_t **out_regs, unsigned **out_offsets, int *out_total)"
  print "{"
  print "    int total = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) total += RX_PDOS[p].n_entries;"
  print "    for (int p=0; p<(int)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])); p++) total += TX_PDOS[p].n_entries;"
  print ""
  print "    ec_pdo_entry_reg_t *regs = calloc((size_t)total + 1, sizeof(*regs));"
  print "    unsigned *offs = calloc((size_t)total, sizeof(*offs));"
  print "    if (!regs || !offs) return -1;"
  print ""
  print "    int k = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) {"
  print "        const ec_pdo_info_t *pdo = &RX_PDOS[p];"
  print "        for (int e=0; e<pdo->n_entries; e++, k++) {"
  print "            regs[k].alias        = 0;"
  print "            regs[k].position     = SLAVE_POS;"
  print "            regs[k].vendor_id    = VENDOR_ID;"
  print "            regs[k].product_code = PRODUCT_CODE;"
  print "            regs[k].index        = pdo->entries[e].index;"
  print "            regs[k].subindex     = pdo->entries[e].subindex;"
  print "            regs[k].offset       = &offs[k];"
  print "        }"
  print "    }"
  print "    for (int p=0; p<(int)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])); p++) {"
  print "        const ec_pdo_info_t *pdo = &TX_PDOS[p];"
  print "        for (int e=0; e<pdo->n_entries; e++, k++) {"
  print "            regs[k].alias        = 0;"
  print "            regs[k].position     = SLAVE_POS;"
  print "            regs[k].vendor_id    = VENDOR_ID;"
  print "            regs[k].product_code = PRODUCT_CODE;"
  print "            regs[k].index        = pdo->entries[e].index;"
  print "            regs[k].subindex     = pdo->entries[e].subindex;"
  print "            regs[k].offset       = &offs[k];"
  print "        }"
  print "    }"
  print "    regs[k] = (ec_pdo_entry_reg_t){0};"
  print "    *out_regs = regs; *out_offsets = offs; *out_total = total;"
  print "    return 0;"
  print "}"
  print ""
  print "static inline int total_rx_entries(void)"
  print "{"
  print "    int n = 0;"
  print "    for (int p=0; p<(int)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])); p++) n += RX_PDOS[p].n_entries;"
  print "    return n;"
  print "}"
}
