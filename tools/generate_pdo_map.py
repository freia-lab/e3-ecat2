#!/usr/bin/env python3
import re
import sys
from pathlib import Path

if len(sys.argv) < 2:
    print("Usage: python3 generate_pdo_map.py ecat_cstruct.h > pdo_map.h")
    sys.exit(1)

text = Path(sys.argv[1]).read_text()

# ---------------------------------------------------------------------
# Extract flat PDO entry list: ec_pdo_entry_info_t ...[] = { ... };
# ---------------------------------------------------------------------
entries_block = re.search(
    r'ec_pdo_entry_info_t\s+[A-Za-z0-9_]+\s*\[\s*\]\s*=\s*\{(.*?)\};',
    text, re.S)

if not entries_block:
    print("ERROR: Could not find ec_pdo_entry_info_t array in file.")
    sys.exit(1)

entries_text = entries_block.group(1)

# Each entry is like {0x3000, 0x01, 8}
entry_re = re.compile(r'\{\s*(0x[0-9A-Fa-f]+)\s*,\s*(0x[0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*\}')
flat_entries = [
    (idx, sub, int(bits))
    for (idx, sub, bits) in entry_re.findall(entries_text)
]

if not flat_entries:
    print("ERROR: No PDO entries parsed.")
    sys.exit(1)

# ---------------------------------------------------------------------
# Extract PDO info list: ec_pdo_info_t ...[] = { {0x1600,count,entries+off}, ... }
# ---------------------------------------------------------------------
pdo_block = re.search(
    r'ec_pdo_info_t\s+[A-Za-z0-9_]+\s*\[\s*\]\s*=\s*\{(.*?)\};',
    text, re.S)

if not pdo_block:
    print("ERROR: Could not find ec_pdo_info_t array in file.")
    sys.exit(1)

pdo_text = pdo_block.group(1)

pdo_re = re.compile(
    r'\{\s*(0x[0-9A-Fa-f]+)\s*,\s*([0-9]+)\s*,[^+]*\+\s*([0-9]+)\s*\}',
    re.S)

pdo_list = []
for idx_hex, count, off in pdo_re.findall(pdo_text):
    pdo_list.append( (idx_hex.lower(), int(count), int(off)) )

if not pdo_list:
    print("ERROR: No PDO infos parsed.")
    sys.exit(1)

# Turn list into dict for slicing
pdo_map = { idx: (count, off) for idx, count, off in pdo_list }

def slice_pdo(pdo_id):
    pdo_id = pdo_id.lower()
    if pdo_id not in pdo_map:
        return []
    count, off = pdo_map[pdo_id]
    return flat_entries[off : off + count]

# Required four PDOs
pdo_order = [
    ("0x1600", "RXPDO_1600_ENTRIES"),
    ("0x1601", "RXPDO_1601_ENTRIES"),
    ("0x1a00", "TXPDO_1A00_ENTRIES"),
    ("0x1a01", "TXPDO_1A01_ENTRIES"),
]

# ---------------------------------------------------------------------
# Emit pdo_map.h
# ---------------------------------------------------------------------

print("#pragma once")
print("#include <ecrt.h>")
print("")
print("/* Generated by generate_pdo_map.py */")
print(f"#define VENDOR_ID     0x0000006c")
print(f"#define PRODUCT_CODE  0x0000a72c")
print(f"#define SLAVE_POS     0")
print("")

for pdo_hex, name in pdo_order:
    arr = slice_pdo(pdo_hex)
    print(f"/* {pdo_hex} */")
    print(f"static const ec_pdo_entry_info_t {name}[] = {{")
    for idx, sub, bits in arr:
        idx_num = int(idx,16)
        sub_num = int(sub,16)
        print(f"    {{0x{idx_num:04X}, 0x{sub_num:02X}, {bits}}},")
    print("};\n")

print("/* Counts */")
print("#define RXPDO_1600_COUNT (int)(sizeof(RXPDO_1600_ENTRIES)/sizeof(RXPDO_1600_ENTRIES[0]))")
print("#define RXPDO_1601_COUNT (int)(sizeof(RXPDO_1601_ENTRIES)/sizeof(RXPDO_1601_ENTRIES[0]))")
print("#define TXPDO_1A00_COUNT (int)(sizeof(TXPDO_1A00_ENTRIES)/sizeof(TXPDO_1A00_ENTRIES[0]))")
print("#define TXPDO_1A01_COUNT (int)(sizeof(TXPDO_1A01_ENTRIES)/sizeof(TXPDO_1A01_ENTRIES[0]))")
print("")

print("static const ec_pdo_info_t RX_PDOS[] = {")
print("    {0x1600, RXPDO_1600_COUNT, RXPDO_1600_ENTRIES},")
print("    {0x1601, RXPDO_1601_COUNT, RXPDO_1601_ENTRIES},")
print("};\n")

print("static const ec_pdo_info_t TX_PDOS[] = {")
print("    {0x1A00, TXPDO_1A00_COUNT, TXPDO_1A00_ENTRIES},")
print("    {0x1A01, TXPDO_1A01_COUNT, TXPDO_1A01_ENTRIES},")
print("};\n")

print("static const ec_sync_info_t SLAVE_SYNC_INFO[] = {")
print("    {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},")
print("    {1, EC_DIR_INPUT,  0, NULL, EC_WD_DISABLE},")
print("    {2, EC_DIR_OUTPUT, (uint8_t)(sizeof(RX_PDOS)/sizeof(RX_PDOS[0])), RX_PDOS, EC_WD_DISABLE},")
print("    {3, EC_DIR_INPUT,  (uint8_t)(sizeof(TX_PDOS)/sizeof(TX_PDOS[0])), TX_PDOS, EC_WD_DISABLE},")
print("    {0xFF, 0, 0, NULL, EC_WD_DISABLE}")
print("};\n")

print("static inline int total_rx_entries(void) {")
print("    return RXPDO_1600_COUNT + RXPDO_1601_COUNT;")
print("}\n")

print("static inline int build_entry_regs(ec_pdo_entry_reg_t **regs_out, unsigned **offs_out, int *count_out)")
print("{")
print("    int total = RXPDO_1600_COUNT + RXPDO_1601_COUNT + TXPDO_1A00_COUNT + TXPDO_1A01_COUNT;")
print("    ec_pdo_entry_reg_t *regs = calloc(total + 1, sizeof(*regs));")
print("    unsigned *offs = calloc(total, sizeof(unsigned));")
print("    if (!regs || !offs) return -1;")
print("    int k = 0;")
print("")
print("    /* RX first */")
print("    for (int p=0;p<2;p++){")
print("        const ec_pdo_info_t *pdo = &RX_PDOS[p];")
print("        for (int e=0;e<pdo->n_entries;e++,k++){")
print("            regs[k].alias=0; regs[k].position=SLAVE_POS;")
print("            regs[k].vendor_id=VENDOR_ID; regs[k].product_code=PRODUCT_CODE;")
print("            regs[k].index=pdo->entries[e].index;")
print("            regs[k].subindex=pdo->entries[e].subindex;")
print("            regs[k].offset=&offs[k];")
print("        }")
print("    }")
print("")
print("    /* TX next */")
print("    for (int p=0;p<2;p++){")
print("        const ec_pdo_info_t *pdo = &TX_PDOS[p];")
print("        for (int e=0;e<pdo->n_entries;e++,k++){")
print("            regs[k].alias=0; regs[k].position=SLAVE_POS;")
print("            regs[k].vendor_id=VENDOR_ID; regs[k].product_code=PRODUCT_CODE;")
print("            regs[k].index=pdo->entries[e].index;")
print("            regs[k].subindex=pdo->entries[e].subindex;")
print("            regs[k].offset=&offs[k];")
print("        }")
print("    }")
print("    regs[k]=(ec_pdo_entry_reg_t){0};")
print("    *regs_out = regs; *offs_out = offs; *count_out = total;")
print("    return 0;")
print("}")
